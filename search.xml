<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ES6 新增特性练习题</title>
      <link href="/2018/08/20/q-es6xtx/"/>
      <url>/2018/08/20/q-es6xtx/</url>
      <content type="html"><![CDATA[<h3 id="1、判断两个-Set-是否相同"><a href="#1、判断两个-Set-是否相同" class="headerlink" title="1、判断两个 Set 是否相同"></a>1、判断两个 Set 是否相同</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">完成 isSameSet 函数，它接受了两个 Set 对象作为参数，请你返回 true/false 来表明这两个 set 的内容是否完全一致，例如：</span><br><span class="line">const a = &#123;&#125;</span><br><span class="line">const b = 1</span><br><span class="line">const c = &apos;ScriptOJ&apos;</span><br><span class="line">const set1 = new Set([a, b, c])</span><br><span class="line">const set2 = new Set([a, c, b])</span><br><span class="line">isSameSet(set1, set2) // =&gt; true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const isSameSet = (set1, set2) =&gt; [...set1].every((o) =&gt; set2.has(o)) &amp;&amp; [...set2].every((o) =&gt; set1.has(o))</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、数组去重"><a href="#2、数组去重" class="headerlink" title="2、数组去重"></a>2、数组去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数 unique(arr)，返回一个去除数组内重复的元素的数组。例如：</span><br><span class="line">unique([0, 1, 2, 2, 3, 3, 4]) // =&gt; [0, 1, 2, 3, 4]</span><br><span class="line">unique([0, 1, &apos;1&apos;, &apos;1&apos;, 2]) // =&gt; [0, 1, &apos;1&apos;, 2]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const unique = (arr) =&gt; [...new Set(arr)]</span><br><span class="line">或</span><br><span class="line">const unique = (arr)  =&gt; Array.from(new Set(arr))</span><br></pre></td></tr></table></figure><h3 id="3、判断美元符号格式"><a href="#3、判断美元符号格式" class="headerlink" title="3、判断美元符号格式"></a>3、判断美元符号格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">完成一个函数 isUSDFormat 返回 true/false 来判断一个字符串是否符合美元格式：</span><br><span class="line">以 $ 开头</span><br><span class="line">如果是小数，保留两位小数；如果不是小数则不显示小数部分</span><br><span class="line">整数部分从小数点上一位开始每隔三位用 , 分割开来</span><br><span class="line">如果整数部分从数字 0 开始，则只会显示一位 0</span><br><span class="line">例如：</span><br><span class="line">isUSDFormat(&apos;$1&apos;) // =&gt; true</span><br><span class="line">isUSDFormat(&apos;$1.0&apos;) // =&gt; false</span><br><span class="line">isUSDFormat(&apos;$100,000.00&apos;) // =&gt; true</span><br><span class="line">isUSDFormat(&apos;$0,000.00&apos;) // =&gt; false</span><br><span class="line">isUSDFormat(&apos;$0.00&apos;) // =&gt; true</span><br><span class="line">isUSDFormat(&apos;$11,23,345.33&apos;) // =&gt; false</span><br><span class="line">isUSDFormat(&apos;$1,123,345.33&apos;) // =&gt; true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const isUSDFormat = str =&gt; (/^\$([1-9]\d&#123;0,2&#125;(,\d&#123;3&#125;)*|0)(\.\d&#123;2&#125;)?$/).test(str)</span><br></pre></td></tr></table></figure><h3 id="4、filter-map"><a href="#4、filter-map" class="headerlink" title="4、filter map"></a>4、filter map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map([[&apos;Jerry&apos;, 12], [&apos;Jimmy&apos;, 13], [&apos;Tomy&apos;, 14]])</span><br><span class="line">m.filterKeys((key) =&gt; key.startsWith(&apos;J&apos;)) // =&gt; Map &#123; Jerry =&gt; 12, Jimmy =&gt; 13 &#125;</span><br><span class="line">m.filterValues((val) =&gt; val &gt;= 13) // =&gt; Map &#123; Jimmy =&gt; 13, Tomy =&gt; 14  &#125;</span><br><span class="line">原有的 map 保持不变</span><br><span class="line">console.log(m) // =&gt; Map &#123; Jerry =&gt; 12 , Jimmy =&gt; 13, Tomy =&gt; 14 &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.filterKeys = function(fn) &#123;</span><br><span class="line">  return new Map([...this].filter(([k, v]) =&gt; fn(k)));</span><br><span class="line">&#125;</span><br><span class="line">Map.prototype.filterValues = function(fn) &#123;</span><br><span class="line">  return new Map([...this].filter(([k, v]) =&gt; fn(v)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、数组的空位填充"><a href="#5、数组的空位填充" class="headerlink" title="5、数组的空位填充"></a>5、数组的空位填充</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 数组有空位的概念，也就数组的一个位置上没有任何的值。例如：</span><br><span class="line">[ , , &apos;Hello&apos;] // =&gt; 0, 1 都是空位, 3 不是空位</span><br><span class="line">空位并不等于 undefined 或者 null。一个位置上如果是 undefined 那么它依然有值，例如 [, , undefined]，0 和 1 都是空位，而 2 不是空位。</span><br><span class="line">请你完成一个函数 fillEmpty，它接受一个数组作为参数，可以把数组里面的所有空位都设置为 &apos;Hello&apos;，例如：</span><br><span class="line">const a = [, , null, undefined, &apos;OK&apos;, ,]</span><br><span class="line">fillEmpty(a)</span><br><span class="line">a 变成 [&apos;Hello&apos;, &apos;Hello&apos;, null, undefined, &apos;OK&apos;, &apos;Hello&apos;]</span><br><span class="line">注意，你要原地修改原先的数组，而不是返回一个新的数组。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fillEmpty = arr =&gt; &#123;</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    if(!(i in arr)) arr[i] = &apos;Hello&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const fillEmpty = (arr) =&gt; &#123;</span><br><span class="line">  Array.from(arr).map((v,i)=&gt;&#123;if(!(i in arr)) arr[i]=&apos;Hello&apos; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、不重复数字"><a href="#6、不重复数字" class="headerlink" title="6、不重复数字"></a>6、不重复数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写一个 JavaScript 函数 uniqueNums，该函数有一个参数 n（一个不大 31 的整数），其返回值是一个数组，该数组内是 n 个随机且不重复的整数，且整数取值范围是 [2, 32]。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const uniqueNums = (n) =&gt; &#123;</span><br><span class="line">  let set = new Set()</span><br><span class="line">  while(set.size &lt; n) &#123;</span><br><span class="line">    set.add(Math.floor(2 + Math.random()*31))</span><br><span class="line">  &#125;</span><br><span class="line">  return [...set]</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const uniqueNums = (n) =&gt; &#123;</span><br><span class="line">  let arr = [];</span><br><span class="line">  while(arr.length !== n) &#123;</span><br><span class="line">    let randomNum = Math.round(Math.random() * 30 + 2);</span><br><span class="line">    if(arr.indexOf(randomNum) === -1) &#123;</span><br><span class="line">      arr.push(randomNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、监听数组变化"><a href="#7、监听数组变化" class="headerlink" title="7、监听数组变化"></a>7、监听数组变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在前端的 MVVM 框架当中，我们经常需要监听数据的变化，而数组是需要监听的重要对象。请你完成 ObserverableArray，它的实例和普通的数组实例功能相同，但是当调用：</span><br><span class="line">push</span><br><span class="line">pop</span><br><span class="line">shift</span><br><span class="line">unshift</span><br><span class="line">splice</span><br><span class="line">sort</span><br><span class="line">reverse</span><br><span class="line">这些方法的时候，除了执行相同的操作，还会把方法名打印出来。 例如：</span><br><span class="line">const arr = new ObserverableArray()</span><br><span class="line">arr.push(&apos;Good&apos;) // =&gt; 打印 &apos;push&apos;，a 变成了 [&apos;Good&apos;]</span><br><span class="line">注意，你不能修改 Array 的 prototype。还有函数 return 的值和原生的操作保持一致。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ObserverableArray() &#123;</span><br><span class="line">  return new Proxy([], &#123;</span><br><span class="line">    get(target, propKey) &#123;</span><br><span class="line">      const matArr = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;];</span><br><span class="line">      matArr.indexOf(propKey) &gt; -1 &amp;&amp; console.log(propKey);</span><br><span class="line">      return target[propKey]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、不用循环生成数组"><a href="#8、不用循环生成数组" class="headerlink" title="8、不用循环生成数组"></a>8、不用循环生成数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">完成 arrWithoutLoop 函数，它会被传入一个整数 n 作为参数，返回一个长度为 n 的数组，数组中每个元素的值等于它的下标。arrWithoutLoop 中不能使用循环控制结构。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arrWithoutLoop = (n) =&gt; [...Array(n)].map((x, i) =&gt; i)</span><br><span class="line">或</span><br><span class="line">const arrWithoutLoop = (n) =&gt; Array.apply(null,&#123;length:n&#125;).map((item,i)=&gt;i)</span><br><span class="line">或</span><br><span class="line">const arrWithoutLoop = n =&gt; [...Array(n).keys()]</span><br><span class="line">或</span><br><span class="line">const arrWithoutLoop = (n, arr = []) =&gt; n ? arr.unshift(n-1) &amp;&amp; arrWithoutLoop(n-1, arr) : arr</span><br></pre></td></tr></table></figure><h3 id="9、后端数据处理"><a href="#9、后端数据处理" class="headerlink" title="9、后端数据处理"></a>9、后端数据处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">从某数据库接口得到如下值：</span><br><span class="line">&#123;</span><br><span class="line">  rows: [</span><br><span class="line">    [&quot;Lisa&quot;, 16, &quot;Female&quot;, &quot;2000-12-01&quot;],</span><br><span class="line">    [&quot;Bob&quot;, 22, &quot;Male&quot;, &quot;1996-01-21&quot;]</span><br><span class="line">  ],</span><br><span class="line">  metaData: [</span><br><span class="line">    &#123; name: &quot;name&quot;, note: &apos;&apos; &#125;,</span><br><span class="line">    &#123; name: &quot;age&quot;, note: &apos;&apos; &#125;,</span><br><span class="line">    &#123; name: &quot;gender&quot;, note: &apos;&apos; &#125;,</span><br><span class="line">    &#123; name: &quot;birthday&quot;, note: &apos;&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">rows 是数据，metaData 是对数据的说明。现写一个函数 parseData，将上面的对象转化为期望的数组：</span><br><span class="line">[</span><br><span class="line">  &#123; name: &quot;Lisa&quot;, age: 16, gender: &quot;Female&quot;, birthday: &quot;2000-12-01&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;Bob&quot;, age: 22, gender: &quot;Male&quot;, birthday: &quot;1996-01-21&quot; &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const parseData = (data) =&gt; &#123;</span><br><span class="line">  let arr = [];</span><br><span class="line">  data.rows.map((row, index) =&gt; &#123;</span><br><span class="line">  let obj = &#123;&#125;;</span><br><span class="line">  row.map((ele, i) =&gt; &#123;</span><br><span class="line">  obj[data.metaData[i].name] = ele</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">    arr.push(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const parseData = (&#123;rows, metaData&#125;) =&gt; rows.map(row =&gt; row.reduce((p, c, i) =&gt; Object.assign(&#123;&#125;, p, &#123;[metaData[i].name]: c&#125;), &#123;&#125;))</span><br><span class="line">或</span><br><span class="line">const parseData = (&#123; rows, metaData &#125;) =&gt;</span><br><span class="line">    rows.map(v =&gt; &#123;</span><br><span class="line">      const newObj = &#123;&#125;</span><br><span class="line">      for (let i in v) &#123;</span><br><span class="line">        newObj[metaData[i].name] = v[i]</span><br><span class="line">      &#125;</span><br><span class="line">      return newObj</span><br><span class="line"> &#125;)</span><br><span class="line"> 或</span><br><span class="line"> const parseData = (data) =&gt; &#123;</span><br><span class="line">   const metaDataArr = data[&apos;metaData&apos;].map(d =&gt; d.name);</span><br><span class="line">   const rows = data[&apos;rows&apos;];</span><br><span class="line">   return rows.map(row =&gt;&#123;</span><br><span class="line">     return &#123;</span><br><span class="line">         [metaDataArr[0]]:row[0],</span><br><span class="line">         [metaDataArr[1]]:row[1],</span><br><span class="line">         [metaDataArr[2]]:row[2],</span><br><span class="line">         [metaDataArr[3]]:row[3]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line"> 或</span><br><span class="line"> const parseData = (data) =&gt; data.rows.map(x =&gt; &#123;</span><br><span class="line">   return data.metaData.reduce((acc, meta, i) =&gt; (&#123; ...acc, [meta.name]: x[i] &#125;) , &#123;&#125;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="10、数组拍平"><a href="#10、数组拍平" class="headerlink" title="10、数组拍平"></a>10、数组拍平</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编写一个 JavaScript 函数，接受一个仅包含数字的 多维数组 ，返回拍平以后的结果。</span><br><span class="line">例如传入：[1, [[2], 3, 4], 5]，返回 [1, 2, 3, 4, 5]。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const flatten = (arr) =&gt; &#123;</span><br><span class="line">  let result = []</span><br><span class="line">  arr.forEach((item)=&gt; &#123;</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">      result = result.concat(flatten(item));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const flatten = (arr) =&gt; &#123;</span><br><span class="line">  return arr.reduce((flat, toFlat) =&gt; &#123;</span><br><span class="line">    return flat.concat(Array.isArray(toFlat) ? flatten(toFlat): toFlat);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const flatten = arr =&gt; arr.length ? arr.toString().split(&apos;,&apos;).map(x =&gt; parseInt(x)) : []</span><br><span class="line">或</span><br><span class="line">const flatten = (arr) =&gt; arr.length !== 0 ? arr.join().split(&apos;,&apos;).map(v =&gt; parseInt(v)) : arr;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Javascript </tag>
            
            <tag> 面试题 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>春泥无芬</title>
      <link href="/2018/08/20/s-chunni/"/>
      <url>/2018/08/20/s-chunni/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">朋友弋肃，一个不折不扣的当代女汉子。看我最近闲来无聊，遂央求我帮她记录一些故事。好的吧，这是金兰结义的代价。</span><br><span class="line"></span><br><span class="line">小人物的小煎熬 ~</span><br><span class="line"></span><br><span class="line">三十岁，梦碎了一地，无处安放的岁月，生分而疏离。</span><br><span class="line"></span><br><span class="line">老掉牙的情节依然发生，</span><br><span class="line">他出了轨虽然临阵收手，</span><br><span class="line">我明白她终生不会原谅，</span><br><span class="line">余生里只剩下一地鸡毛。</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS常见面试题</title>
      <link href="/2018/08/16/q-jsmst/"/>
      <url>/2018/08/16/q-jsmst/</url>
      <content type="html"><![CDATA[<h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="1、javascript-的-typeof-返回哪些数据类型"><a href="#1、javascript-的-typeof-返回哪些数据类型" class="headerlink" title="1、javascript 的 typeof 返回哪些数据类型"></a>1、javascript 的 typeof 返回哪些数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object, number, function, boolean, underfind, string</span><br><span class="line">typeof null;//object</span><br><span class="line">typeof isNaN;//</span><br><span class="line">typeof isNaN(123)</span><br><span class="line">typeof [];//object</span><br><span class="line">Array.isARRAY(); es5</span><br><span class="line">toString.call([]);//”[object Array]” var arr=[];</span><br><span class="line">arr.constructor;//Array</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、例举-3-种强制类型转换和-2-种隐式类型转换"><a href="#2、例举-3-种强制类型转换和-2-种隐式类型转换" class="headerlink" title="2、例举 3 种强制类型转换和 2 种隐式类型转换?"></a>2、例举 3 种强制类型转换和 2 种隐式类型转换?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">强制（parseInt,parseFloat,Number()）</span><br><span class="line">隐式（==）</span><br><span class="line">1==”1”//true</span><br><span class="line">null==undefined//true</span><br></pre></td></tr></table></figure><h3 id="3、split-join-的区别"><a href="#3、split-join-的区别" class="headerlink" title="3、split() join() 的区别"></a>3、split() join() 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">split()是切割成数组的形式，</span><br><span class="line">join()是将数组转换成字符串</span><br></pre></td></tr></table></figure><h3 id="4、数组方法-pop-push-unshift-shift"><a href="#4、数组方法-pop-push-unshift-shift" class="headerlink" title="4、数组方法 pop() push() unshift() shift()"></a>4、数组方法 pop() push() unshift() shift()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop()尾部删除</span><br><span class="line">push()尾部添加</span><br><span class="line">unshift()头部添加</span><br><span class="line">shift()头部删除</span><br></pre></td></tr></table></figure><h3 id="5、事件绑定和普通事件的区别"><a href="#5、事件绑定和普通事件的区别" class="headerlink" title="5、事件绑定和普通事件的区别"></a>5、事件绑定和普通事件的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件</span><br><span class="line">如果说给同一个元素绑定了两次或者多次相同类型的事件，那么后面的绑定会覆盖前面的绑定</span><br><span class="line">不支持 DOM 事件流 事件捕获阶段目标元素阶段=&gt;事件冒泡阶段</span><br><span class="line">addEventListener</span><br><span class="line">如果说给同一个元素绑定了两次或者多次相同类型的事件，所有的绑定将会依次触发</span><br><span class="line">支持 DOM 事件流的</span><br><span class="line">进行事件绑定传参不需要 on 前缀</span><br><span class="line">ie9 开始，ie11 edge：addEventListener</span><br><span class="line">ie9 以前：attachEvent/detachEvent</span><br><span class="line">进行事件类型传参需要带上 on 前缀</span><br><span class="line">这种方式只支持事件冒泡，不支持事件捕获</span><br></pre></td></tr></table></figure><h3 id="6、IE-和-DOM-事件流的区别"><a href="#6、IE-和-DOM-事件流的区别" class="headerlink" title="6、IE 和 DOM 事件流的区别"></a>6、IE 和 DOM 事件流的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行顺序不一样、</span><br><span class="line">参数不一样</span><br><span class="line">事件加不加 on</span><br><span class="line">this 指向问题</span><br><span class="line">IE9 以前：attachEvent(“onclick”)、detachEvent(“onclick”)</span><br><span class="line">IE9 开始跟 DOM 事件流是一样的，都是 addEventListener</span><br></pre></td></tr></table></figure><h3 id="7、IE-和标准下有哪些兼容性的写法"><a href="#7、IE-和标准下有哪些兼容性的写法" class="headerlink" title="7、IE 和标准下有哪些兼容性的写法"></a>7、IE 和标准下有哪些兼容性的写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ev = ev || window.event</span><br><span class="line">document.documentElement.clientWidth || document.body.clientWidth</span><br><span class="line">var target = ev.srcElement||ev.target</span><br></pre></td></tr></table></figure><h3 id="8、call-和-apply-的区别"><a href="#8、call-和-apply-的区别" class="headerlink" title="8、call 和 apply 的区别"></a>8、call 和 apply 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call 和 apply 相同点：都是为了用一个本不属于一个对象的方法，让这个对象去执行</span><br><span class="line">toString.call([],1,2,3)</span><br><span class="line">toString.apply([],[1,2,3])</span><br><span class="line">Object.call(this,obj1,obj2,obj3)</span><br><span class="line">Object.apply(this,arguments)</span><br></pre></td></tr></table></figure><h3 id="9、b-继承-a-的方法"><a href="#9、b-继承-a-的方法" class="headerlink" title="9、b 继承 a 的方法"></a>9、b 继承 a 的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">考点：继承的多种方式</span><br><span class="line">function b()&#123;&#125;</span><br><span class="line">b.protoototype=new a;</span><br></pre></td></tr></table></figure><h3 id="10、指针、闭包、作用域"><a href="#10、指针、闭包、作用域" class="headerlink" title="10、指针、闭包、作用域"></a>10、指针、闭包、作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this：指向调用上下文</span><br><span class="line">闭包：内层作用域可以访问外层作用域的变量</span><br><span class="line">作用域：定义一个函数就开辟了一个局部作用域，整个 js 执行环境有一个全局作用域</span><br><span class="line">闭包的缺点：滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数</span><br></pre></td></tr></table></figure><h3 id="11、事件委托是什么"><a href="#11、事件委托是什么" class="headerlink" title="11、事件委托是什么"></a>11、事件委托是什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">符合 W3C 标准的事件绑定 addEventLisntener /attachEvent</span><br><span class="line">让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</span><br></pre></td></tr></table></figure><h3 id="12、如何阻止事件冒泡和默认事件"><a href="#12、如何阻止事件冒泡和默认事件" class="headerlink" title="12、如何阻止事件冒泡和默认事件"></a>12、如何阻止事件冒泡和默认事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e. stopPropagation();//标准浏览器</span><br><span class="line">event.canceBubble=true;//ie9 之前</span><br><span class="line">阻止默认事件：为了不让 a 点击之后跳转，我们就要给他的点击事件进行阻止</span><br><span class="line">return false</span><br><span class="line">e.preventDefault();</span><br></pre></td></tr></table></figure><h3 id="13、document-load-和-document-ready-的区别"><a href="#13、document-load-和-document-ready-的区别" class="headerlink" title="13、document load 和 document ready 的区别"></a>13、document load 和 document ready 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document.onload 是在结构和样式加载完才执行 js</span><br><span class="line">window.onload：不仅仅要在结构和样式加载完，还要执行完所有的样式、图片这些资源文件，全部加载完才会触发 window.onload 事件</span><br><span class="line">Document.ready 原生中没有这个方法，jquery 中有 $().ready(function)</span><br></pre></td></tr></table></figure><h3 id="14、编写一个数组去重的方法"><a href="#14、编写一个数组去重的方法" class="headerlink" title="14、编写一个数组去重的方法"></a>14、编写一个数组去重的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,1,3,4,2,4,7]; =&gt;[1,3,4,2,7] 一个比较简单的实现就是：</span><br><span class="line">先创建一个空数组，用来保存最终的结果</span><br><span class="line">循环原数组中的每个元素</span><br><span class="line">再对每个元素进行二次循环，判断是否有与之相同的元素，如果没有，将把这个元素放到新数组中</span><br><span class="line">返回这个新数组</span><br><span class="line">function oSort(arr) &#123;</span><br><span class="line">var result =&#123;&#125;;</span><br><span class="line">var newArr=[];</span><br><span class="line">for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">if(!result[arr]) &#123;</span><br><span class="line">newArr.push(arr)</span><br><span class="line">result[arr]=1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return newArr</span><br><span class="line">&#125;&lt;/arr.length;i++)</span><br></pre></td></tr></table></figure><h3 id="15、foo-foo-bar-，这行代码是什么意思？"><a href="#15、foo-foo-bar-，这行代码是什么意思？" class="headerlink" title="15、foo = foo||bar ，这行代码是什么意思？"></a>15、foo = foo||bar ，这行代码是什么意思？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这种写法称之为短路表达式</span><br><span class="line">if(!foo) foo = bar; //如果 foo 存在，值不变，否则把 bar 的值赋给 foo。</span><br><span class="line">短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。</span><br><span class="line">注意 if 条件的真假判定，记住以下是 false 的情况：空字符串、false、undefined、null、0</span><br></pre></td></tr></table></figure><h3 id="16、随机选取-10–100-之间的-10-个数字，存入一个数组，并排序。"><a href="#16、随机选取-10–100-之间的-10-个数字，存入一个数组，并排序。" class="headerlink" title="16、随机选取 10–100 之间的 10 个数字，存入一个数组，并排序。"></a>16、随机选取 10–100 之间的 10 个数字，存入一个数组，并排序。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var iArray = [];</span><br><span class="line">funtion getRandom(istart, iend)&#123;</span><br><span class="line">var iChoice = istart - iend +1;</span><br><span class="line">return Math.floor(Math.random() * iChoice + istart;</span><br><span class="line">&#125;</span><br><span class="line">Math.random()就是获取 0-1 之间的随机数（永远获取不到 1）</span><br><span class="line">for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">var result= getRandom(10,100);</span><br><span class="line">iArray.push(result);</span><br><span class="line">&#125;</span><br><span class="line">iArray.sort();</span><br></pre></td></tr></table></figure><h3 id="17、把两个数组合并，并删除第二个元素。"><a href="#17、把两个数组合并，并删除第二个元素。" class="headerlink" title="17、把两个数组合并，并删除第二个元素。"></a>17、把两个数组合并，并删除第二个元素。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">var bArray = [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];</span><br><span class="line">var cArray = array1.concat(bArray);</span><br><span class="line">cArray.splice(1,1);</span><br></pre></td></tr></table></figure><h3 id="18、写一个-function，清除字符串前后的空格。（兼容所有浏览器）"><a href="#18、写一个-function，清除字符串前后的空格。（兼容所有浏览器）" class="headerlink" title="18、写一个 function，清除字符串前后的空格。（兼容所有浏览器）"></a>18、写一个 function，清除字符串前后的空格。（兼容所有浏览器）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用自带接口 trim()，考虑兼容性：</span><br><span class="line">if (!String.prototype.trim) &#123;</span><br><span class="line">String.prototype.trim = function() &#123;</span><br><span class="line">return this.replace(/^\s+/, &quot;&quot;).replace(/\s+$/,&quot;&quot;);</span><br><span class="line">//\s 匹配空白字符：回车、换行、制表符 tab 空格</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// test the function</span><br><span class="line">var str = &quot; \t\n test string &quot;.trim();</span><br><span class="line">alert(str == &quot;test string&quot;); // alerts &quot;true&quot;</span><br></pre></td></tr></table></figure><h3 id="19、列举浏览器对象模型-BOM-里常用的至少-4-个对象，并列举-window-对象的常用方法至少-5-个"><a href="#19、列举浏览器对象模型-BOM-里常用的至少-4-个对象，并列举-window-对象的常用方法至少-5-个" class="headerlink" title="19、列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个"></a>19、列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象：Window document location screen history navigator</span><br><span class="line">方法：Alert() confirm() prompt() open() close()</span><br></pre></td></tr></table></figure><h3 id="20、文档对象模型-DOM-里-document-的常用的查找访问节点的方法"><a href="#20、文档对象模型-DOM-里-document-的常用的查找访问节点的方法" class="headerlink" title="20、文档对象模型 DOM 里 document 的常用的查找访问节点的方法"></a>20、文档对象模型 DOM 里 document 的常用的查找访问节点的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document.getElementById 根据元素 id 查找元素</span><br><span class="line">Document.getElementByName 根据元素 name 查找元素</span><br><span class="line">Document.getElementTagName 根据指定的元素名查找元素</span><br></pre></td></tr></table></figure><h3 id="21、iframe-的优缺点？"><a href="#21、iframe-的优缺点？" class="headerlink" title="21、iframe 的优缺点？"></a>21、iframe 的优缺点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：解决加载缓慢的第三方内容如图标和广告等的加载问题,Security sandbox,并行加载脚本</span><br><span class="line">缺点：iframe 会阻塞主页面的 Onload 事件,即时内容为空，加载也需要时间,没有语意</span><br></pre></td></tr></table></figure><h3 id="22、谈谈-Cookie-的弊端？"><a href="#22、谈谈-Cookie-的弊端？" class="headerlink" title="22、谈谈 Cookie 的弊端？"></a>22、谈谈 Cookie 的弊端？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`Cookie`数量和长度的限制。每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。</span><br><span class="line">安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。</span><br><span class="line">有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用</span><br></pre></td></tr></table></figure><h3 id="23、DOM-操作——怎样添加、移除、移动、复制、创建和查找节点。"><a href="#23、DOM-操作——怎样添加、移除、移动、复制、创建和查找节点。" class="headerlink" title="23、DOM 操作——怎样添加、移除、移动、复制、创建和查找节点。"></a>23、DOM 操作——怎样添加、移除、移动、复制、创建和查找节点。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 创建新节点</span><br><span class="line">createDocumentFragment() // 创建一个 DOM 片段</span><br><span class="line">createElement() // 创建一个具体的元素</span><br><span class="line">createTextNode() // 创建一个文本节点</span><br><span class="line">2. 添加、移除、替换、插入</span><br><span class="line">appendChild()</span><br><span class="line">removeChild()</span><br><span class="line">replaceChild()</span><br><span class="line">insertBefore() // 在已有的子节点前插入一个新的子节点</span><br><span class="line">3. 查找</span><br><span class="line">getElementsByTagName() // 通过标签名称</span><br><span class="line">getElementsByName() // 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，其中包括 id 等于 name 值的)</span><br><span class="line">getElementById() // 通过元素 Id，唯一性</span><br></pre></td></tr></table></figure><h3 id="24、js-延迟加载的方式有哪些？"><a href="#24、js-延迟加载的方式有哪些？" class="headerlink" title="24、js 延迟加载的方式有哪些？"></a>24、js 延迟加载的方式有哪些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer 和 async</span><br><span class="line">动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</span><br><span class="line">按需异步载入 js</span><br></pre></td></tr></table></figure><h3 id="25、documen-write-和-innerHTML-的区别？"><a href="#25、documen-write-和-innerHTML-的区别？" class="headerlink" title="25、documen.write 和 innerHTML 的区别？"></a>25、documen.write 和 innerHTML 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.write 只能重绘整个页面</span><br><span class="line">innerHTML 可以重绘页面的一部分</span><br></pre></td></tr></table></figure><h3 id="26、哪些操作会造成内存泄漏？"><a href="#26、哪些操作会造成内存泄漏？" class="headerlink" title="26、哪些操作会造成内存泄漏？"></a>26、哪些操作会造成内存泄漏？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</span><br><span class="line">垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</span><br><span class="line">setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</span><br><span class="line">闭包</span><br><span class="line">控制台日志</span><br><span class="line">循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</span><br></pre></td></tr></table></figure><h3 id="27、IE-和-DOM-事件流的区别"><a href="#27、IE-和-DOM-事件流的区别" class="headerlink" title="27、IE 和 DOM 事件流的区别"></a>27、IE 和 DOM 事件流的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行顺序不一样、</span><br><span class="line">参数不一样</span><br><span class="line">事件加不加 on</span><br><span class="line">this 指向问题</span><br></pre></td></tr></table></figure><h3 id="28、什么是闭包？-写一个简单的闭包？"><a href="#28、什么是闭包？-写一个简单的闭包？" class="headerlink" title="28、什么是闭包？ 写一个简单的闭包？"></a>28、什么是闭包？ 写一个简单的闭包？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</span><br><span class="line">function outer()&#123;</span><br><span class="line">var num = 1;</span><br><span class="line">function inner()&#123;</span><br><span class="line">var n = 2;</span><br><span class="line">alert(n + num);</span><br><span class="line">&#125;</span><br><span class="line">return inner;</span><br><span class="line">&#125;</span><br><span class="line">outer()();</span><br></pre></td></tr></table></figure><h3 id="29、javascript-中的垃圾回收机制？"><a href="#29、javascript-中的垃圾回收机制？" class="headerlink" title="29、javascript 中的垃圾回收机制？"></a>29、javascript 中的垃圾回收机制？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC回收。如果两个对象互相引用，而不再 被第 3 者所引用，那么这两个互相引用的对象也会被回收。因为函数 a 被 b 引用，b 又被 a 外的 c 引用，这就是为什么 函数 a 执行后不会被回收的原因。</span><br></pre></td></tr></table></figure><h3 id="30、什么是同源策略？"><a href="#30、什么是同源策略？" class="headerlink" title="30、什么是同源策略？"></a>30、什么是同源策略？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同协议、端口、域名的安全策略，由网景(Netscape)公司提出来的安全协议！</span><br></pre></td></tr></table></figure><h3 id="31、BOM-对象有哪些，列举-window-对象？"><a href="#31、BOM-对象有哪些，列举-window-对象？" class="headerlink" title="31、BOM 对象有哪些，列举 window 对象？"></a>31、BOM 对象有哪些，列举 window 对象？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window 对象 ，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；</span><br><span class="line">document 对象，文档对象；</span><br><span class="line">location 对象，浏览器当前 URL 信息；</span><br><span class="line">navigator 对象，浏览器本身信息；</span><br><span class="line">screen 对象，客户端屏幕信息；</span><br><span class="line">history 对象，浏览器访问历史信息；</span><br></pre></td></tr></table></figure><h3 id="32、bind-live-delegate-的区别"><a href="#32、bind-live-delegate-的区别" class="headerlink" title="32、bind(), live(), delegate()的区别"></a>32、bind(), live(), delegate()的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回 jQuery 对象。</span><br><span class="line">live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回 jQuery 对象。</span><br><span class="line">delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。</span><br></pre></td></tr></table></figure><h3 id="33、你如何优化自己的代码？"><a href="#33、你如何优化自己的代码？" class="headerlink" title="33、你如何优化自己的代码？"></a>33、你如何优化自己的代码？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码重用</span><br><span class="line">避免全局变量（命名空间，封闭空间，模块化 mvc..）</span><br><span class="line">拆分函数避免函数过于臃肿：单一职责原则</span><br><span class="line">适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程</span><br><span class="line">内存管理，尤其是闭包中的变量释放</span><br></pre></td></tr></table></figure><h3 id="34、列举常用的-js-框架以及分别适用的领域"><a href="#34、列举常用的-js-框架以及分别适用的领域" class="headerlink" title="34、列举常用的 js 框架以及分别适用的领域"></a>34、列举常用的 js 框架以及分别适用的领域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jquery：简化了 js 的一些操作，并且提供了一些非常好用的 API</span><br><span class="line">jquery ui、jquery-easyui：在 jqeury 的基础上提供了一些常用的组件 日期，下拉框，表格这些组件</span><br><span class="line">require.js、sea.js（阿里的玉帛）+》模块化开发使用的</span><br><span class="line">zepto：精简版的 jquery，常用于手机 web 前端开发 提供了一些手机页面实用功能,touch</span><br><span class="line">ext.js：跟 jquery 差不多，但是不开源，也没有 jquery 轻量</span><br><span class="line">angular、knockoutjs、avalon(去哪儿前端总监)：MV*框架，适合用于单页应用开发(SPA)</span><br></pre></td></tr></table></figure><h3 id="35、列出-3-条以上-ff-和-IE-的脚本兼容问题"><a href="#35、列出-3-条以上-ff-和-IE-的脚本兼容问题" class="headerlink" title="35、列出 3 条以上 ff 和 IE 的脚本兼容问题"></a>35、列出 3 条以上 ff 和 IE 的脚本兼容问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在 IE 下可通过 document.frames[&quot;id&quot;];得到该 IFRAME 对象，而在火狐下则是通过 document.getElementById(&quot;content_panel_if&quot;).contentWindow;</span><br><span class="line">IE 的写法： _tbody=_table.childNodes[0]</span><br><span class="line">在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白&quot;&quot;， 而 ie 不会返回空白,可以通过 if(&quot;&quot; != node.nodeName)过滤掉空白子对象</span><br><span class="line">模拟点击事件</span><br><span class="line">if(document.all)&#123; //ie 下</span><br><span class="line">document.getElementById(&quot;a3&quot;).click();</span><br><span class="line">&#125;</span><br><span class="line">else&#123; //非 IE</span><br><span class="line">var evt = document.createEvent(&quot;MouseEvents&quot;);</span><br><span class="line">evt.initEvent(&quot;click&quot;, true, true);</span><br><span class="line">document.getElementById(&quot;a3&quot;).dispatchEvent(evt);</span><br><span class="line">&#125;</span><br><span class="line">事件注册</span><br><span class="line">if (isIE)&#123;window.attachEvent(&quot;onload&quot;, init);&#125;else&#123;window.addEventListener(&quot;load&quot;, init, false);&#125;</span><br></pre></td></tr></table></figure><h2 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h2><h3 id="1、什么是-webkit-么-怎么用浏览器的各种工具来调试和-debug-代码"><a href="#1、什么是-webkit-么-怎么用浏览器的各种工具来调试和-debug-代码" class="headerlink" title="1、什么是 webkit 么? 怎么用浏览器的各种工具来调试和 debug 代码?"></a>1、什么是 webkit 么? 怎么用浏览器的各种工具来调试和 debug 代码?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Webkit 是浏览器引擎，包括 html 渲染和 js 解析功能，手机浏览器的主流内核，与之相对应的引擎有 Gecko（Mozilla Firefox 等使用）和 Trident（也称 MSHTML，IE 使用）。</span><br><span class="line">对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js 调试工具使用，熟练使用这些工具可以快速提高解决问题的效率</span><br></pre></td></tr></table></figure><h3 id="2、如何测试前端代码-知道-BDD-TDD-Unit-Test-么-怎么测试你的前端工程-mocha-sinon-jasmin-qUnit"><a href="#2、如何测试前端代码-知道-BDD-TDD-Unit-Test-么-怎么测试你的前端工程-mocha-sinon-jasmin-qUnit" class="headerlink" title="2、如何测试前端代码? 知道 BDD, TDD, Unit Test 么? 怎么测试你的前端工程(mocha, sinon, jasmin, qUnit..)?"></a>2、如何测试前端代码? 知道 BDD, TDD, Unit Test 么? 怎么测试你的前端工程(mocha, sinon, jasmin, qUnit..)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">了解 BDD 行为驱动开发与 TDD 测试驱动开发已经单元测试相关概念</span><br></pre></td></tr></table></figure><h3 id="3、前端-templating-Mustache-underscore-handlebars-是干嘛的-怎么用"><a href="#3、前端-templating-Mustache-underscore-handlebars-是干嘛的-怎么用" class="headerlink" title="3、前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?"></a>3、前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在Javascript、PHP、Python、Perl 等多种编程语言中。</span><br><span class="line">Underscore 封装了常用的 JavaScript 对象操作方法，用于提高开发效率。</span><br><span class="line">Handlebars 是 JavaScript 一个语义模板库，通过对 view 和 data 的分离来快速构建Web 模板。</span><br></pre></td></tr></table></figure><h3 id="4、-Javascript-作用域链"><a href="#4、-Javascript-作用域链" class="headerlink" title="4、 Javascript 作用域链?"></a>4、 Javascript 作用域链?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解变量和函数的访问范围和生命周期，全局作用域与局部作用域的区别，JavaScript中没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。</span><br></pre></td></tr></table></figure><h3 id="5、-谈谈-this-对象的理解。"><a href="#5、-谈谈-this-对象的理解。" class="headerlink" title="5、 谈谈 this 对象的理解。"></a>5、 谈谈 this 对象的理解。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解不同形式的函数调用方式下的 this 指向，理解事件函数、定时函数中的 this 指向，函数的调用形式决定了 this 的指向。</span><br></pre></td></tr></table></figure><h3 id="6、-eval-是做什么的？"><a href="#6、-eval-是做什么的？" class="headerlink" title="6、 eval 是做什么的？"></a>6、 eval 是做什么的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它的功能是把对应的字符串解析成 JS 代码并运行；应该避免使用 eval，不安全，非常耗性能（2 个步骤，一次解析成 js 语句，一次执行）</span><br></pre></td></tr></table></figure><h3 id="7、-关于事件，IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#7、-关于事件，IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="7、 关于事件，IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>7、 关于事件，IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1].在 IE 中,事件对象是作为一个全局变量来保存和维护的.所有的浏览器事件,不管是用</span><br><span class="line">户触发的，还是其他事件,都会更新 window.event 对象.所以在代码中，只要调用</span><br><span class="line">window.event 就可以获取事件对象， 再 event.srcElement 就可以取得触发事件的元素进</span><br><span class="line">行进一步处理.</span><br><span class="line">[2].在 FireFox 中，事件对象却不是全局对象，一般情况下，是现场发生，现场使用，FireFox</span><br><span class="line">把事件对象自动传给事件处理程序. 关于事件的兼容性处理要熟练掌握，事件对象具体哪些属性存在兼容性问题，IE 与标准事</span><br><span class="line">件模型事件冒泡与事件捕获的支持要理解</span><br></pre></td></tr></table></figure><h3 id="8、-什么是闭包（closure），为什么要用它？"><a href="#8、-什么是闭包（closure），为什么要用它？" class="headerlink" title="8、 什么是闭包（closure），为什么要用它？"></a>8、 什么是闭包（closure），为什么要用它？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单的理解是函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域</span><br><span class="line">使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值</span><br></pre></td></tr></table></figure><h3 id="9、new-操作符具体干了什么呢"><a href="#9、new-操作符具体干了什么呢" class="headerlink" title="9、new 操作符具体干了什么呢?"></a>9、new 操作符具体干了什么呢?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</span><br><span class="line">2、属性和方法被加入到 this 引用的对象中。</span><br><span class="line">3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</span><br></pre></td></tr></table></figure><h3 id="10、js-延迟加载的方式有哪些？"><a href="#10、js-延迟加载的方式有哪些？" class="headerlink" title="10、js 延迟加载的方式有哪些？"></a>10、js 延迟加载的方式有哪些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方案一：&lt;script&gt;标签的 async=&quot;async&quot;属性（详细参见：script 标签的 async 属性）</span><br><span class="line">方案二：&lt;script&gt;标签的 defer=defer属性</span><br><span class="line">方案三：动态创建&lt;script&gt;标签</span><br><span class="line">方案四：AJAX eval（使用 AJAX 得到脚本内容，然后通过 eval_r(xmlhttp.responseText)</span><br><span class="line">来运行脚本）</span><br><span class="line">方案五：iframe 方式</span><br></pre></td></tr></table></figure><h3 id="11、模块化开发怎么做？"><a href="#11、模块化开发怎么做？" class="headerlink" title="11、模块化开发怎么做？"></a>11、模块化开发怎么做？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">理解模块化开发模式：浏览器端 requirejs，seajs；服务器端 nodejs；ES6 模块化；fis、</span><br><span class="line">webpack 等前端整体模块化解决方案；grunt、gulp 等前端工作流的使用</span><br></pre></td></tr></table></figure><h3 id="12、requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#12、requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="12、requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>12、requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心是 js 的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存</span><br></pre></td></tr></table></figure><h3 id="13、数组和对象有哪些原生方法，列举一下？"><a href="#13、数组和对象有哪些原生方法，列举一下？" class="headerlink" title="13、数组和对象有哪些原生方法，列举一下？"></a>13、数组和对象有哪些原生方法，列举一下？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Array.concat( ) 连接数组</span><br><span class="line">Array.join( ) 将数组元素连接起来以构建一个字符串</span><br><span class="line">Array.length 数组的大小</span><br><span class="line">Array.pop( ) 删除并返回数组的最后一个元素</span><br><span class="line">Array.push( ) 给数组添加元素</span><br><span class="line">Array.reverse( ) 颠倒数组中元素的顺序</span><br><span class="line">Array.shift( ) 将元素移出数组</span><br><span class="line">Array.slice( ) 返回数组的一部分</span><br><span class="line">Array.sort( ) 对数组元素进行排序</span><br><span class="line">Array.splice( ) 插入、删除或替换数组的元素</span><br><span class="line">Array.toLocaleString( ) 把数组转换成局部字符串</span><br><span class="line">Array.toString( ) 将数组转换成一个字符串</span><br><span class="line">Array.unshift( ) 在数组头部插入一个元素</span><br><span class="line">Object 对象的常用方法</span><br><span class="line">Object.hasOwnProperty( ) 检查属性是否被继承</span><br><span class="line">Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型</span><br><span class="line">Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性</span><br><span class="line">Object.toLocaleString( ) 返回对象的本地字符串表示</span><br><span class="line">Object.toString( ) 定义一个对象的字符串表示</span><br><span class="line">Object.valueOf( ) 指定对象的原始值</span><br></pre></td></tr></table></figure><h3 id="14、如何编写高性能的-Javascript？"><a href="#14、如何编写高性能的-Javascript？" class="headerlink" title="14、如何编写高性能的 Javascript？"></a>14、如何编写高性能的 Javascript？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用 DocumentFragment 优化多次 append</span><br><span class="line">通过模板元素 clone ，替代 createElement</span><br><span class="line">使用一次 innerHTML 赋值代替构建 dom 元素</span><br><span class="line">使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</span><br><span class="line">使用 Array 做为 StringBuffer ，代替字符串拼接的操作</span><br><span class="line">将循环控制量保存到局部变量</span><br><span class="line">顺序无关的遍历时，用 while 替代 for</span><br><span class="line">将条件分支，按可能性顺序从高到低排列</span><br><span class="line">在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if</span><br><span class="line">使用三目运算符替代条件分支</span><br><span class="line">需要不断执行的时候，优先考虑使用 setInterval</span><br></pre></td></tr></table></figure><h3 id="15、javascript-对象的几种创建方式？"><a href="#15、javascript-对象的几种创建方式？" class="headerlink" title="15、javascript 对象的几种创建方式？"></a>15、javascript 对象的几种创建方式？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 工厂模式</span><br><span class="line">2. 构造函数模式</span><br><span class="line">3. 原型模式</span><br><span class="line">4. 混合构造函数和原型模式</span><br><span class="line">5. 动态原型模式</span><br><span class="line">6. 寄生构造函数模式</span><br><span class="line">7. 稳妥构造函数模式</span><br></pre></td></tr></table></figure><h3 id="16、javascript-继承的-6-种方法？"><a href="#16、javascript-继承的-6-种方法？" class="headerlink" title="16、javascript 继承的 6 种方法？"></a>16、javascript 继承的 6 种方法？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 原型链继承</span><br><span class="line">2. 借用构造函数继承</span><br><span class="line">3. 组合继承(原型+借用构造)</span><br><span class="line">4. 原型式继承</span><br><span class="line">5. 寄生式继承</span><br><span class="line">6. 寄生组合式继承</span><br></pre></td></tr></table></figure><h3 id="17、eval-是做什么的？"><a href="#17、eval-是做什么的？" class="headerlink" title="17、eval 是做什么的？"></a>17、eval 是做什么的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 它的功能是把对应的字符串解析成 JS 代码并运行</span><br><span class="line">2. 应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）</span><br></pre></td></tr></table></figure><h3 id="18、JavaScript-原型，原型链-有什么特点？"><a href="#18、JavaScript-原型，原型链-有什么特点？" class="headerlink" title="18、JavaScript 原型，原型链 ? 有什么特点？"></a>18、JavaScript 原型，原型链 ? 有什么特点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链</span><br><span class="line">2. 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链</span><br></pre></td></tr></table></figure><h3 id="19、分别阐述-split-slice-splice-join-？"><a href="#19、分别阐述-split-slice-splice-join-？" class="headerlink" title="19、分别阐述 split(),slice(),splice(),join()？"></a>19、分别阐述 split(),slice(),splice(),join()？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于 Array</span><br><span class="line">split()即把字符串分离开，以数组方式存储。归属于 Stringstring</span><br><span class="line">slice()方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()</span><br><span class="line">splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。</span><br></pre></td></tr></table></figure><h3 id="20、http-状态码有那些？分别代表是什么意思？"><a href="#20、http-状态码有那些？分别代表是什么意思？" class="headerlink" title="20、http 状态码有那些？分别代表是什么意思？"></a>20、http 状态码有那些？分别代表是什么意思？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">100-199 用于指定客户端应相应的某些动作。</span><br><span class="line">200-299 用于表示请求成功。</span><br><span class="line">300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</span><br><span class="line">400-499 用于指出客户端的错误。</span><br><span class="line">400 语义有误，当前请求无法被服务器理解。</span><br><span class="line">401 当前请求需要用户验证</span><br><span class="line">403 服务器已经理解请求，但是拒绝执行它。</span><br><span class="line">500-599 用于支持服务器错误。</span><br><span class="line">503 – 服务不可用</span><br></pre></td></tr></table></figure><h3 id="21、针对-jQuery-的优化方法？"><a href="#21、针对-jQuery-的优化方法？" class="headerlink" title="21、针对 jQuery 的优化方法？"></a>21、针对 jQuery 的优化方法？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优先使用 ID 选择器</span><br><span class="line">jquery 获取到的 DOM 元素如果需要多次使用，建议使用一个变量将其保存起来，因为操作 DOM 的过程是非常耗费性能的</span><br><span class="line">在 class 前使用 tag(标签名)</span><br><span class="line">给选择器一个上下文</span><br><span class="line">慎用 .live()方法（应该说尽量不要使用）</span><br><span class="line">使用 data()方法存储临时变量</span><br></pre></td></tr></table></figure><h3 id="22、Zepto-的点透问题如何解决？"><a href="#22、Zepto-的点透问题如何解决？" class="headerlink" title="22、Zepto 的点透问题如何解决？"></a>22、Zepto 的点透问题如何解决？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">点透主要是由于两个 div 重合，例如：一个 div 调用 show()，一个 div 调用 hide()；</span><br><span class="line">这个时候当点击上面的 div 的时候就会影响到下面的那个 div；</span><br><span class="line">解决办法主要有 2 种：</span><br><span class="line">github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响</span><br><span class="line">应，https://github.com/ftlabs/fastclick</span><br><span class="line">将它用 script 标签引入页面（该库支持 AMD，于是你也可以按照 AMD 规范，用诸如</span><br><span class="line">require.js 的模块加载器引入），并且在 dom ready 时初始化在 body 上，</span><br><span class="line">根据分析，如果不引入其它类库，也不想自己按照上述 fastclcik 的思路再开发一套</span><br><span class="line">东西，需要 1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件</span><br><span class="line">阻止掉默认行为（下面的“divClickUnder”对 click 事件的捕获，在 ios 的 safari，</span><br><span class="line">click 的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即</span><br><span class="line">可以被 event.preventDefault()阻止的行为）。</span><br></pre></td></tr></table></figure><h3 id="23、知道各种-JS-框架-Angular-Backbone-Ember-React-Meteor-Knockout…-么-能讲出他们各自的优点和缺点么"><a href="#23、知道各种-JS-框架-Angular-Backbone-Ember-React-Meteor-Knockout…-么-能讲出他们各自的优点和缺点么" class="headerlink" title="23、知道各种 JS 框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?"></a>23、知道各种 JS 框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">知识面的宽度，流行框架要多多熟悉</span><br><span class="line">angular、backbone、knockout 都是完整的 MV*框架</span><br><span class="line">angular 是双向数据绑定的，backbone、knockout 是单向数据绑定的</span><br><span class="line">React 只是单纯地 View 层</span><br></pre></td></tr></table></figure><h3 id="24、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#24、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="24、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>24、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</span><br><span class="line">实现界面交互</span><br><span class="line">提升用户体验</span><br><span class="line">有了 Node.js，前端可以实现服务端的一些事情</span><br><span class="line">前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，</span><br><span class="line">参与项目，快速高质量完成实现效果图，精确到 1px；</span><br><span class="line">与团队成员，UI 设计，产品经理的沟通；</span><br><span class="line">做好的页面结构，页面重构和用户体验；</span><br><span class="line">处理 hack，兼容、写出优美的代码格式；</span><br><span class="line">针对服务器的优化、拥抱最新前端技术。</span><br><span class="line">其它相关的加分项：</span><br><span class="line">都使用和了解过哪些编辑器?都使用和了解过哪些日常工具?</span><br><span class="line">都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器?</span><br><span class="line">瀑布流布局或者流式布局是否有了解</span><br><span class="line">HTML5 都有哪些新的 API?</span><br><span class="line">都用过什么代码调试工具?</span><br><span class="line">是否有接触过或者了解过重构。</span><br><span class="line">你遇到过比较难的技术问题是？你是如何解决的？</span><br></pre></td></tr></table></figure><h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><h3 id="1、对-Node-的优点和缺点提出了自己的看法："><a href="#1、对-Node-的优点和缺点提出了自己的看法：" class="headerlink" title="1、对 Node 的优点和缺点提出了自己的看法："></a>1、对 Node 的优点和缺点提出了自己的看法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（优点）因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。此外，与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</span><br><span class="line">（缺点）Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子。</span><br></pre></td></tr></table></figure><h3 id="2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">至少给出自己的思路（url-hash,可以使用已有的一些框架 history.js 等）</span><br></pre></td></tr></table></figure><h3 id="3、Node-js-的适用场景？"><a href="#3、Node-js-的适用场景？" class="headerlink" title="3、Node.js 的适用场景？"></a>3、Node.js 的适用场景？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实时应用：如在线聊天，实时通知推送等等（如 socket.io）</span><br><span class="line">分布式应用：通过高效的并行 I/O 使用已有的数据</span><br><span class="line">工具类应用：海量的工具，小到前端压缩部署（如 grunt），大到桌面图形界面应用程序</span><br><span class="line">游戏类应用：游戏领域对实时和并发有很高的要求（如网易的 pomelo 框架）</span><br><span class="line">利用稳定接口提升 Web 渲染能力</span><br><span class="line">前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯 Javascript 全栈式 MEAN 架构）</span><br></pre></td></tr></table></figure><h3 id="4、-如果会用-node-知道-route-middleware-cluster-nodemon-pm2-server-side-rendering-么"><a href="#4、-如果会用-node-知道-route-middleware-cluster-nodemon-pm2-server-side-rendering-么" class="headerlink" title="4、(如果会用 node)知道 route, middleware, cluster, nodemon, pm2, server-side rendering 么?"></a>4、(如果会用 node)知道 route, middleware, cluster, nodemon, pm2, server-side rendering 么?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nodejs 相关概念的理解程度</span><br></pre></td></tr></table></figure><h3 id="5、解释一下-Backbone-的-MVC-实现方式"><a href="#5、解释一下-Backbone-的-MVC-实现方式" class="headerlink" title="5、解释一下 Backbone 的 MVC 实现方式"></a>5、解释一下 Backbone 的 MVC 实现方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流行的 MVC 架构模式</span><br></pre></td></tr></table></figure><h3 id="6、什么是“前端路由”-什么时候适合使用“前端路由”-“前端路由”有哪些优点和缺点"><a href="#6、什么是“前端路由”-什么时候适合使用“前端路由”-“前端路由”有哪些优点和缺点" class="headerlink" title="6、什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?"></a>6、什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">熟悉前后端通信相关知识</span><br><span class="line">前端路由就是在不进行后端请求的情况下对页面进行跳转</span><br></pre></td></tr></table></figure><h3 id="7、对-Node-的优点和缺点提出了自己的看法？"><a href="#7、对-Node-的优点和缺点提出了自己的看法？" class="headerlink" title="7、对 Node 的优点和缺点提出了自己的看法？"></a>7、对 Node 的优点和缺点提出了自己的看法？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在 Node上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。</span><br><span class="line">与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，因此客户端和服务</span><br><span class="line">器端都用同一种语言编写，这是非常美妙的事情。</span><br><span class="line">缺点：</span><br><span class="line">Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变。</span><br><span class="line">缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。</span><br></pre></td></tr></table></figure><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="1、如何解决跨域问题"><a href="#1、如何解决跨域问题" class="headerlink" title="1、如何解决跨域问题?"></a>1、如何解决跨域问题?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</span><br><span class="line">出于安全考虑，服务器不允许 ajax 跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建 script 标签，使用标签的 src 属性访问 js 文件的形式获取 js脚本，并且这个 js 脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案</span><br></pre></td></tr></table></figure><h3 id="2、页面编码和被请求的资源编码如果不一致如何处理？"><a href="#2、页面编码和被请求的资源编码如果不一致如何处理？" class="headerlink" title="2、页面编码和被请求的资源编码如果不一致如何处理？"></a>2、页面编码和被请求的资源编码如果不一致如何处理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于 ajax 请求传递的参数，如果是 get 请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于 get 请求的参数需要使用encodeURIComponent 函数对参数进行编码处理，后台开发语言都有相应的解码 api。对于 post 请求不需要进行编码</span><br></pre></td></tr></table></figure><h3 id="3、简述-ajax-的过程。"><a href="#3、简述-ajax-的过程。" class="headerlink" title="3、简述 ajax 的过程。"></a>3、简述 ajax 的过程。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</span><br><span class="line">创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息</span><br><span class="line">设置响应 HTTP 请求状态变化的函数</span><br><span class="line">发送 HTTP 请求</span><br><span class="line">获取异步调用返回的数据</span><br><span class="line">使用 JavaScript 和 DOM 实现局部刷新</span><br></pre></td></tr></table></figure><h3 id="4、阐述一下异步加载。"><a href="#4、阐述一下异步加载。" class="headerlink" title="4、阐述一下异步加载。"></a>4、阐述一下异步加载。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步加载的方案： 动态插入 script 标签</span><br><span class="line">通过 ajax 去获取 js 代码，然后通过 eval 执行</span><br><span class="line">script 标签上添加 defer 或者 async 属性</span><br><span class="line">创建并插入 iframe，让它异步执行 js</span><br></pre></td></tr></table></figure><h3 id="5、解释-jsonp-的原理，以及为什么不是真正的-ajax"><a href="#5、解释-jsonp-的原理，以及为什么不是真正的-ajax" class="headerlink" title="5、解释 jsonp 的原理，以及为什么不是真正的 ajax"></a>5、解释 jsonp 的原理，以及为什么不是真正的 ajax</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jsonp 并不是一种数据格式，而 json 是一种数据格式，jsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是 ajax 技术</span><br></pre></td></tr></table></figure><h3 id="6、什么是-Ajax-和-JSON，它们的优缺点。"><a href="#6、什么是-Ajax-和-JSON，它们的优缺点。" class="headerlink" title="6、什么是 Ajax 和 JSON，它们的优缺点。"></a>6、什么是 Ajax 和 JSON，它们的优缺点。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ajax 是全称是 asynchronous JavaScript andXML，即异步 JavaScript 和 xml，用于在Web 页面中实现异步数据交互，实现页面局部刷新。</span><br><span class="line">优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验</span><br><span class="line">缺点：对搜索引擎不友好；要实现 ajax 下的前后退功能成本较大；可能造成请求数的增加跨域问题限制；JSON 是一种轻量级的数据交换格式，ECMA 的一个子集</span><br><span class="line">优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）</span><br></pre></td></tr></table></figure><h3 id="7、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#7、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="7、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>7、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分为 4 个步骤：</span><br><span class="line">当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS查询。这能使浏览器获得请求对应的 IP 地址。</span><br><span class="line">浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</span><br><span class="line">一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。</span><br><span class="line">此时，Web 服务器提供资源服务，客户端开始下载资源。</span><br></pre></td></tr></table></figure><h3 id="8、ajax-请求的时候-get-和-post-方式的区别"><a href="#8、ajax-请求的时候-get-和-post-方式的区别" class="headerlink" title="8、ajax 请求的时候 get 和 post 方式的区别"></a>8、ajax 请求的时候 get 和 post 方式的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get 一般用来进行查询操作，url 地址有长度限制，请求的参数都暴露在 url 地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。</span><br><span class="line">post 请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于 http请求体中，数据不会暴漏在 url 地址中。</span><br></pre></td></tr></table></figure><h3 id="9、ajax-请求时，如何解释-json-数据"><a href="#9、ajax-请求时，如何解释-json-数据" class="headerlink" title="9、ajax 请求时，如何解释 json 数据"></a>9、ajax 请求时，如何解释 json 数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 eval() 或者 JSON.parse() 鉴于安全性考虑，推荐使用 JSON.parse()更靠谱，对数据的安全性更好。</span><br></pre></td></tr></table></figure><h3 id="10、两个数组的差集"><a href="#10、两个数组的差集" class="headerlink" title="10、两个数组的差集"></a>10、两个数组的差集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">function arrChange( a, b )&#123;</span><br><span class="line">var resultData = [];</span><br><span class="line">for(var i = 0; i &lt; a.length; i++)&#123;</span><br><span class="line">    var flag = false;</span><br><span class="line">    for(var j = 0; j &lt; b.length; j++)&#123;</span><br><span class="line">        if(b[j].id == a[i].id)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">        resultData.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">function arrChange( a, b )&#123;</span><br><span class="line">    for (var i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; a.length; j++) &#123;</span><br><span class="line">            if (a[j].id == b[i].id) &#123;</span><br><span class="line">                a.splice(j, 1);</span><br><span class="line">                j = j - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Javascript </tag>
            
            <tag> Jquery </tag>
            
            <tag> Zepto </tag>
            
            <tag> Ajax </tag>
            
            <tag> Json </tag>
            
            <tag> Nodejs </tag>
            
            <tag> Requirejs </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>落叶无痕</title>
      <link href="/2018/08/15/s-luoye/"/>
      <url>/2018/08/15/s-luoye/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">朋友弋肃，一个不折不扣的当代女汉子。看我最近闲来无聊，遂央求我帮她记录一些故事。好的吧，这是金兰结义的代价。</span><br><span class="line"></span><br><span class="line">小人物的小结局 ~</span><br><span class="line"></span><br><span class="line">二十五岁，花落的声音，不知所措的岁月，纠结而扎心。</span><br><span class="line"></span><br><span class="line">冬日的婚礼上，</span><br><span class="line">她画着浓浓的新娘妆，</span><br><span class="line">他穿着单薄的新郎装，</span><br><span class="line">宣誓时，他和她，四目相对，都红了眼眶，</span><br><span class="line">伴娘的我，见证了这青梅竹马长跑的感情。</span><br><span class="line">我想这就是爱情纯美的样子吧。</span><br><span class="line">唯有祝福。</span><br><span class="line"></span><br><span class="line">难得周末时光，</span><br><span class="line">她生着他的闷气，</span><br><span class="line">他玩着他的游戏，</span><br><span class="line">闲暇时，他和她，各自安好，都毫不在意，</span><br><span class="line">朋友的我，目睹了这走进围城耗尽的感情。</span><br><span class="line">我想这就是爱情褪色的样子吧。</span><br><span class="line">唯有叹息。</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS练习题</title>
      <link href="/2017/11/17/q-jsal/"/>
      <url>/2017/11/17/q-jsal/</url>
      <content type="html"><![CDATA[<h3 id="1、把数字转换成中文"><a href="#1、把数字转换成中文" class="headerlink" title="1、把数字转换成中文"></a>1、把数字转换成中文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">完成将 toChineseNum， 可以将数字转换成中文大写的表示，处理到万级别。</span><br><span class="line">例如 toChineseNum(12345)，返回 一万二千三百四十五。</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">const toChineseNum = (num) =&gt; &#123;</span><br><span class="line">    if (num === 0) &#123;</span><br><span class="line">        return &apos;零&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    const bit = [&apos;&apos;, &apos;十&apos;, &apos;百&apos;, &apos;千&apos;];</span><br><span class="line">    const unit = [&apos;零&apos;, &apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;, &apos;七&apos;, &apos;八&apos;, &apos;九&apos;];</span><br><span class="line">    const section = [&apos;&apos;, &apos;万&apos;];</span><br><span class="line">    let sectionPos = 0;</span><br><span class="line">    let resultStr = &apos;&apos;;</span><br><span class="line">    let piece, needZero = false;</span><br><span class="line">    function toCNum(n) &#123;</span><br><span class="line">        let bitPos = 0, rs = &apos;&apos;, zeroNum = 0;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            let curNum = n % 10;</span><br><span class="line">            if (curNum === 0) &#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">                bitPos++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (bitPos === zeroNum)</span><br><span class="line">                    zeroNum = 0;</span><br><span class="line">                else if (zeroNum &gt; 0) &#123;</span><br><span class="line">                    rs = &apos;零&apos; + rs;</span><br><span class="line">                    zeroNum = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                rs = unit[curNum] + bit[bitPos++] + rs;</span><br><span class="line">            &#125;</span><br><span class="line">            n = Math.floor(n / 10);</span><br><span class="line">        &#125;</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        piece = num % 10000;</span><br><span class="line">        resultStr = toCNum(piece) + section[sectionPos] + (needZero ? &apos;零&apos; : &apos;&apos;) + resultStr;</span><br><span class="line">        needZero = piece &lt; 1000 &amp;&amp; piece &gt; 0;</span><br><span class="line">        sectionPos++;</span><br><span class="line">        num = Math.floor(num / 10000);</span><br><span class="line">    &#125;</span><br><span class="line">    return resultStr;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const toChineseNum = (num) =&gt; &#123;</span><br><span class="line">    let str = &apos;零一二三四五六七八九&apos;,</span><br><span class="line">    str2 = [&apos;&apos;, &apos;十&apos;, &apos;百&apos;, &apos;千&apos;];</span><br><span class="line">    let Clu = Array.from( [...num.toString()].reverse(),</span><br><span class="line">(v, i) =&gt; str[v] + (i == 4 ? &apos;万&apos; : (v == 0 ? &apos;&apos; : str2[i % 4]))).reverse().join(&apos;&apos;)</span><br><span class="line">.replace(/零+/g, &apos;零&apos;)</span><br><span class="line">.replace(/(零+$)/, &apos;&apos;)</span><br><span class="line">.replace(/零+(?=万)/, &apos;&apos;);</span><br><span class="line">    return　 Clu;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const toChineseNum = (num) =&gt; &#123;</span><br><span class="line">    let unit = [&apos;&apos;, &apos;十&apos;, &apos;百&apos;, &apos;千&apos;, &apos;万&apos;]</span><br><span class="line">    let numArr = [&apos;零&apos;, &apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;, &apos;七&apos;, &apos;八&apos;, &apos;九&apos;]</span><br><span class="line">    let arrNum = num.toString().split(&quot;&quot;).reverse();</span><br><span class="line">    let strArr = arrNum.map((v, i) =&gt; &#123;</span><br><span class="line">     if (i === 4 &amp;&amp; parseInt(v) === 0) &#123;</span><br><span class="line">        return &quot;万&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      i = i &gt; 4 ? i - 4 : i;</span><br><span class="line">      return parseInt(v) === 0 ? numArr[v] : numArr[v] + unit[i - 0]</span><br><span class="line">    &#125;)</span><br><span class="line">    return strArr.reverse().join(&quot;&quot;).replace(/(零(?=零))|(零$)|(零(?=万))/g, &apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、循环调节列表"><a href="#2、循环调节列表" class="headerlink" title="2、循环调节列表"></a>2、循环调节列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">页面上有这么一个列表：</span><br><span class="line">&lt;ul id=&apos;adjustable-list&apos;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;1&lt;/span&gt;</span><br><span class="line">    &lt;button class=&apos;up&apos;&gt;UP&lt;/button&gt;</span><br><span class="line">    &lt;button class=&apos;down&apos;&gt;DOWN&lt;/button&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;2&lt;/span&gt;</span><br><span class="line">    &lt;button class=&apos;up&apos;&gt;UP&lt;/button&gt;</span><br><span class="line">    &lt;button class=&apos;down&apos;&gt;DOWN&lt;/button&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;3&lt;/span&gt;</span><br><span class="line">    &lt;button class=&apos;up&apos;&gt;UP&lt;/button&gt;</span><br><span class="line">    &lt;button class=&apos;down&apos;&gt;DOWN&lt;/button&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">点击 UP 按钮会使得该 li 元素在列表中上升一个位置，点击 DOWN 按钮会使得该 li 元素下降一个位置。点击最后的元素的 DOWN 按钮会使得元素回到第一个位置，点击第一个元素的 UP 按钮会使其回到最后的位置。</span><br><span class="line">页面上已经存在该列表，你只需要完成 initAdjustableList() 函数，给元素添加事件。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const initAdjustableList = () =&gt; &#123;</span><br><span class="line">    var ul = document.getElementById(&apos;adjustable-list&apos;),</span><br><span class="line">      btns = ul.getElementsByTagName(&apos;button&apos;),</span><br><span class="line">      lis = ul.getElementsByTagName(&apos;li&apos;),</span><br><span class="line">      len = lis.length;</span><br><span class="line"></span><br><span class="line">    [...btns].forEach(d =&gt; &#123;</span><br><span class="line">        d.onclick = e =&gt; &#123;</span><br><span class="line">            let text = e.target.innerText;</span><br><span class="line"></span><br><span class="line">            [...lis].forEach((d, i) =&gt; &#123;</span><br><span class="line">                if (d.isEqualNode(e.target.parentNode)) &#123;</span><br><span class="line">                    if (text == &apos;UP&apos;) &#123;</span><br><span class="line">                        ul.insertBefore(d, lis[i-1])</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        ul.insertBefore(d, lis[i+2 &gt; len ? 0 : i + 2])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、操作-Cookie"><a href="#3、操作-Cookie" class="headerlink" title="3、操作 Cookie"></a>3、操作 Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">完成 cookieJar 单例，它有三个方法：</span><br><span class="line">set(name, value, days)：设置 cookie 的值，days 为多少天以后过期。</span><br><span class="line">get(name)：获取 cookie 的值。</span><br><span class="line">remove(name)：删除 cookie 的值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const cookieJar = &#123;</span><br><span class="line">  set (name, value, days) &#123;</span><br><span class="line">    document.cookie=`$&#123;name&#125;=$&#123;value&#125;;expires=$&#123;new Date(Date.now()+days*24*3600*1000)&#125;`</span><br><span class="line">  &#125;,</span><br><span class="line">  get (name) &#123;</span><br><span class="line">    let cookie=document.cookie</span><br><span class="line">    let reg=new RegExp(`$&#123;name&#125;=([^;]+)`)</span><br><span class="line">   var result=reg.exec(cookie)</span><br><span class="line">   return result[1]</span><br><span class="line">  &#125;,</span><br><span class="line">  remove (name) &#123;</span><br><span class="line">     document.cookie=`$&#123;name&#125;=outdate;expires=$&#123;new Date(Date.now()-36110000)&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const cookieJar = &#123;</span><br><span class="line">  set (name, value, days) &#123;</span><br><span class="line">    const d = new Date();</span><br><span class="line">    d.setDate(d.getDate() + days)</span><br><span class="line">    document.cookie = `$&#123;name&#125;=$&#123;value&#125;; expires=$&#123;d&#125;`</span><br><span class="line">  &#125;,</span><br><span class="line">  get (name) &#123;</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    document.cookie.split(&apos;;&apos;).forEach(s =&gt; &#123;</span><br><span class="line">      s = s.trim();</span><br><span class="line">      const key = s.slice(0, s.indexOf(&apos;=&apos;));</span><br><span class="line">      const value = s.slice(s.indexOf(&apos;=&apos;) + 1);</span><br><span class="line">      obj[key] = value;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj[name];</span><br><span class="line">  &#125;,</span><br><span class="line">  remove (name) &#123;</span><br><span class="line">    this.set(name, &apos;&apos;, -1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、实现-js-数据类型的判断"><a href="#4、实现-js-数据类型的判断" class="headerlink" title="4、实现 js 数据类型的判断"></a>4、实现 js 数据类型的判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最新的 Javascript 标准规定了六种基本数据类型(number, null, undefined, string, boolean, symbol) 和基于 Object 衍生的其它原生数据类型</span><br><span class="line">写出 type 函数，它传入一个参数，返回它的数据类型（用小写字母），比如: type(new Date)，返回 date。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const type = (obj) =&gt; &#123;</span><br><span class="line">  let dataType = &#123;</span><br><span class="line">    &apos;[object Null]&apos; : &apos;null&apos;,</span><br><span class="line">    &apos;[object Undefined]&apos; : &apos;undefined&apos;,</span><br><span class="line">    &apos;[object Boolean]&apos; : &apos;boolean&apos;,</span><br><span class="line">    &apos;[object Number]&apos; : &apos;number&apos;,</span><br><span class="line">    &apos;[object String]&apos; : &apos;string&apos;,</span><br><span class="line">    &apos;[object Function]&apos; : &apos;function&apos;,</span><br><span class="line">    &apos;[object Array]&apos; : &apos;array&apos;,</span><br><span class="line">    &apos;[object Date]&apos; : &apos;date&apos;,</span><br><span class="line">    &apos;[object RegExp]&apos; : &apos;regexp&apos;,</span><br><span class="line">    &apos;[object Object]&apos; : &apos;object&apos;,</span><br><span class="line">    &apos;[object Symbol]&apos; : &apos;symbol&apos;,</span><br><span class="line">    &apos;[object Map]&apos; : &apos;map&apos;,</span><br><span class="line">    &apos;[object Set]&apos; : &apos;set&apos;,</span><br><span class="line">    &apos;[object Int8Array]&apos; : &apos;int8array&apos;,</span><br><span class="line">    &apos;[object Error]&apos; : &apos;error&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  return  dataType[Object.prototype.toString.call(obj)]</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const type = (obj) =&gt; &#123;</span><br><span class="line">  return Object.prototype.toString.call(obj).slice(8,-1).toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、转换驼峰命名"><a href="#5、转换驼峰命名" class="headerlink" title="5、转换驼峰命名"></a>5、转换驼峰命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小科去了一家新的公司做前端主管，发现里面的前端代码有一部分是 C/C++ 程序员写的，他们喜欢用下划线命名，例如： is_good。小科决定写个脚本来全部替换掉这些变量名。</span><br><span class="line">完成 toCamelCaseVar 函数，它可以接受一个字符串作为参数，可以把类似于 is_good 这样的变量名替换成 isGood。</span><br><span class="line">变量名首尾的下划线不需要做处理，中间的下划线全部删除并且处理成驼峰。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const toCamelCaseVar = (v) =&gt; (/^_+/.exec(v) ? /^_+/.exec(v)[0] : &apos;&apos;) + v.replace(/(^_+)|(_+$)/g,&apos;&apos;).replace(/_+[\w$]/g,x=&gt;x[x.length-1].toUpperCase())+ (/_+$/.exec(v) ? /_+$/.exec(v)[0] : &apos;&apos;)</span><br><span class="line">或</span><br><span class="line">const toCamelCaseVar = (variable) =&gt; &#123;</span><br><span class="line">   return variable.replace(/([^_])_+([^_])/g, function (all, b, c) &#123;</span><br><span class="line">        return b+c.toUpperCase()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Javascript </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webstorm常用快捷键</title>
      <link href="/2017/07/17/q-webstormK/"/>
      <url>/2017/07/17/q-webstormK/</url>
      <content type="html"><![CDATA[<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl + shift + n 打开工程中的文件</span><br><span class="line">Ctrl+E 最近打开的文件</span><br><span class="line">Shift+F6 重命名</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+N 查找类</span><br><span class="line">Ctrl+Shift+N 查找文件</span><br><span class="line">Ctrl+Shift+Alt+N 查找类中的方法或变量</span><br><span class="line">Alt+F1 查找代码所在位置</span><br><span class="line">Ctrl+R 替换文本</span><br><span class="line">Ctrl+F 查找文本</span><br><span class="line">ctrl + b 跳到变量申明处</span><br><span class="line">ctrl + [] 匹配 &#123;&#125;[]</span><br></pre></td></tr></table></figure><h3 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+先上键</span><br><span class="line">Ctrl+X 删除行</span><br><span class="line">Ctrl+D 复制行</span><br><span class="line">ctrl + x 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容</span><br><span class="line">ctrl + r 替换</span><br><span class="line">ctrl + shift + up 行移动</span><br><span class="line">shift + alt + up 块移动(if()&#123;&#125;,while()&#123;&#125;语句块的移动)</span><br><span class="line">ctrl + d: 行复制</span><br><span class="line">ctrl + shift + ]/[ 选中块代码</span><br><span class="line">ctrl + /  单行注释</span><br><span class="line">ctrl + shift + /  块注释</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctrl+shift+ up/down 上下移动句子</span><br><span class="line">ctrl+alt+L 格式化代码</span><br><span class="line">Ctrl+J 自动代码</span><br><span class="line">Ctrl+Shift+Space 自动补全代码</span><br><span class="line">Ctrl+空格 代码提示</span><br><span class="line">Ctrl+Alt+Space 类名或接口名提示</span><br><span class="line">Ctrl+P 方法参数提示</span><br><span class="line">F2 或Shift+F2 高亮错误或警告快速定位</span><br><span class="line">代码标签输入完成后，按Tab，生成代码</span><br><span class="line">选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</span><br><span class="line">Ctrl+W 选中代码，连续按会有其他效果</span><br><span class="line">选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+H 显示类结构图</span><br><span class="line">Ctrl+Q 显示注释文档</span><br><span class="line">Alt+Shift+C 对比最近修改的代码</span><br><span class="line">Ctrl+Alt+ left/right 返回至上次浏览的位置</span><br><span class="line">Alt+ left/right 切换代码视图</span><br><span class="line">Alt+ Up/Down 在方法间快速移动定位</span><br><span class="line">Ctrl+Shift+Up/Down 代码向上/下移动。</span><br><span class="line">Ctrl+Up/Down 光标跳转到第一行或最后一行下</span><br><span class="line">Ctrl+B 快速打开光标处的类或方法</span><br><span class="line">Alt+1 快速打开或隐藏工程面板</span><br><span class="line">ctrl + F12 可以显示当前文件的结构</span><br><span class="line">ctrl + &apos;-/+&apos; 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。</span><br><span class="line">ctrl + &apos;.&apos; 折叠选中的代码的代码。</span><br><span class="line">ctrl+shift+ /-展开/折叠</span><br></pre></td></tr></table></figure><h3 id="不常用快捷键"><a href="#不常用快捷键" class="headerlink" title="不常用快捷键"></a>不常用快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctrl + j 输出模板</span><br><span class="line">Alt+回车 导入包,自动修正</span><br><span class="line">Ctrl+Alt+O 优化导入的类和包</span><br><span class="line">Alt+Insert 生成代码(如get,set方法,构造函数等)</span><br><span class="line">Ctrl+E或者Alt+Shift+C 最近更改的代码</span><br><span class="line">alt + left/right 标签切换</span><br><span class="line">ctrl + alt + T 围绕包裹代码</span><br><span class="line">ctrl + shift + i  显示当前CSS选择器或者JS函数的详细信息</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Webstorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>花开无心</title>
      <link href="/2017/07/15/s-huakai/"/>
      <url>/2017/07/15/s-huakai/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">朋友弋肃，一个不折不扣的当代女汉子。看我最近闲来无聊，遂央求我帮她记录一些故事。好的吧，这是金兰结义的代价。</span><br><span class="line"></span><br><span class="line">小人物的小情绪 ~</span><br><span class="line"></span><br><span class="line">十五岁，花开的季节，我们共同走过的青春，廉价而难忘。</span><br><span class="line"></span><br><span class="line">那是在一次聚餐</span><br><span class="line">他坐在她的对面</span><br><span class="line">第一眼是他冷冷的侧脸</span><br><span class="line">第二眼是他唱歌的瞬间</span><br><span class="line">四目相对间他眼神如电</span><br><span class="line">她不知所措的飘忽躲闪</span><br><span class="line"></span><br><span class="line">每次校园偶遇想要搭讪</span><br><span class="line">无奈只是擦肩而过无言</span><br><span class="line">他行走匆匆</span><br><span class="line">她形色匆匆</span><br><span class="line">直到毕业</span><br><span class="line">直到分开</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小草无根</title>
      <link href="/2016/08/15/s-xiaocao/"/>
      <url>/2016/08/15/s-xiaocao/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">朋友弋肃，一个不折不扣的当代女汉子。看我最近闲来无聊，遂央求我帮她记录一些故事。好的吧，这是金兰结义的代价。</span><br><span class="line"></span><br><span class="line">小人物的小故事 ~</span><br><span class="line">年龄还小，小草疯长的季节，我们共同走过的年少，幼稚而多情。</span><br><span class="line"></span><br><span class="line">那天放学回家</span><br><span class="line">他和伙伴们拉拉扯扯边走边说闲话</span><br><span class="line">她在几十米后亦步亦趋的像丑小鸭</span><br><span class="line">时光就这么不紧不慢的刻录着童话</span><br><span class="line"></span><br><span class="line">这秋天的傍晚凉风习习中夕阳如画</span><br><span class="line">小路两旁的杨树林风吹的呼呼啦啦</span><br><span class="line">绿中带黄的落叶三三两两飘飘洒洒</span><br><span class="line">人群中他的背影那么优雅高高大大</span><br><span class="line">听不出他唱着老歌动情的声音沙哑</span><br><span class="line"></span><br><span class="line">多年以后机缘巧合他们互通了电话</span><br><span class="line">原来他也像她当年一样默默中意她</span><br><span class="line">只是阴错阳差几年她已有了新的他</span><br><span class="line">那年空留牵挂</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="那个村庄"><a href="#那个村庄" class="headerlink" title="那个村庄"></a>那个村庄</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个有点落后的农村，一排排的青砖平房里零星的夹杂着几间红瓦房和毛坯房，格外突出的两栋二层楼是整个村子的翘楚，特别的鹤立鸡群。</span><br><span class="line">肃的家是被几排大杨树包围着的单薄的平房，由于建房时资金缺乏，所有的墙都建成了单坯墙，和比人家双坯墙相比显得格外的单薄。她的爸妈都不是父母偏爱的孩子，所有事情都要自力更生，只能这样。所以后来，每当夏季雨季来临时，她都特别的害怕，担心木质不够扎实的杨树会在狂风骤雨中折断， 担心折断的大树砸塌了单坯墙的房子，担心倒塌的房子把自己活埋。噩梦一样包围的不安全感一直持续着，但她没人可以诉说，尤其是看到爸妈不以为然的表情。多年以后，肃在一个雨季南方城市的大楼里，望着窗外因台风而折断的树木，依旧带着淡淡的不安，并庆幸自己离开了那个村庄。</span><br><span class="line">肃是一个没有亲和力的孩子，和别人都淡淡的保持着距离，很不合群。肃与我亲近，或许是因为我们同样生活在一个不安定的家庭，有着经常争吵的父母，同样的缺乏安全感，同样的理性不近人情。家乡孩子们的童年很热闹，大家一起跳皮筋、跳绳子、抓石子、丢沙包、捏泥人、弹弹珠、翻元宝、玩纸牌、捉爬蚱、爬树逮知了，随便一个小东西能玩一天。肃喜欢躺在院子里看云，看带有线条画的武侠小书，偶尔心情好时会和我一起跳皮筋。她不喜欢其他活动，她有洁癖，不喜欢摸脏东西，就连石子也不行。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS常见面试题</title>
      <link href="/2016/06/16/q-cssmst/"/>
      <url>/2016/06/16/q-cssmst/</url>
      <content type="html"><![CDATA[<h2 id="HTML和CSS"><a href="#HTML和CSS" class="headerlink" title="HTML和CSS"></a>HTML和CSS</h2><h3 id="1、常用浏览器的内核分别是什么"><a href="#1、常用浏览器的内核分别是什么" class="headerlink" title="1、常用浏览器的内核分别是什么?"></a>1、常用浏览器的内核分别是什么?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IE: trident 内核</span><br><span class="line">Firefox：gecko 内核</span><br><span class="line">Safari:webkit 内核</span><br><span class="line">Opera:以前是 presto 内核，Opera 现已改用 Google Chrome 的 Blink 内核</span><br><span class="line">Chrome:Blink(基于 webkit，Google 与 Opera Software 共同开发)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、HTML文件里Doctype是干什么的？"><a href="#2、HTML文件里Doctype是干什么的？" class="headerlink" title="2、HTML文件里Doctype是干什么的？"></a>2、HTML文件里Doctype是干什么的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前。</span><br><span class="line">此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）</span><br></pre></td></tr></table></figure><h3 id="3、Quirks模式是什么？它和-tandards-模式有什么区别？"><a href="#3、Quirks模式是什么？它和-tandards-模式有什么区别？" class="headerlink" title="3、Quirks模式是什么？它和 tandards 模式有什么区别？"></a>3、Quirks模式是什么？它和 tandards 模式有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。</span><br><span class="line">在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS提供更好的支持，</span><br><span class="line">然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果 IE6 支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？</span><br><span class="line">在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD 当成了这个“参数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定 如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks模式（怪癖模式，诡异模式，怪异模式）。</span><br><span class="line">区别：总体会有布局、样式解析和脚本执行三个方面的区别。</span><br><span class="line">盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border。</span><br><span class="line">设置行内元素的高宽：在 Standards 模式下，给&lt;span&gt;等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。</span><br><span class="line">设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用</span><br><span class="line">margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平</span><br><span class="line">居中，但在 quirks 模式下却会失效。（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）</span><br></pre></td></tr></table></figure><h3 id="4、div-css-的布局较-table-布局有什么优点？"><a href="#4、div-css-的布局较-table-布局有什么优点？" class="headerlink" title="4、div+css 的布局较 table 布局有什么优点？"></a>4、div+css 的布局较 table 布局有什么优点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">改版的时候更方便 只要改 css 文件。</span><br><span class="line">页面加载速度更快、结构化清晰、页面显示简洁。</span><br><span class="line">表现与结构相分离。</span><br><span class="line">易于优化（seo）搜索引擎更友好，排名更容易靠前。</span><br></pre></td></tr></table></figure><h3 id="5、img的alt与title-有何异同？strong与em的异同？"><a href="#5、img的alt与title-有何异同？strong与em的异同？" class="headerlink" title="5、img的alt与title 有何异同？strong与em的异同？"></a>5、img的alt与title 有何异同？strong与em的异同？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:alt(alt text):为不能显示图像、窗体或 applets 的用户代理（UA），alt 属性用来指定替换文字。替换文字的语言由 lang 属性指定。(在 IE 浏览器下会在没有 title 时把 alt当成 tool tip 显示)</span><br><span class="line">title(tool tip):该属性为设置该属性的元素提供建议性的信息。</span><br><span class="line">strong:粗体强调标签，强调，表示内容的重要性</span><br><span class="line">em:斜体强调标签，更强烈强调，表示内容的强调点</span><br></pre></td></tr></table></figure><h3 id="6、渐进增强和优雅降级之间有什么不同？"><a href="#6、渐进增强和优雅降级之间有什么不同？" class="headerlink" title="6、渐进增强和优雅降级之间有什么不同？"></a>6、渐进增强和优雅降级之间有什么不同？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</span><br><span class="line">优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</span><br><span class="line">区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</span><br><span class="line">“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。</span><br><span class="line">在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏</span><br><span class="line">览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</span><br><span class="line">“渐进增强”观点则认为应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。那么问题来了。现在产品经理看到 IE6,7,8 网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃 CSS3）</span><br></pre></td></tr></table></figure><h3 id="7、为什么利用多个域名来存储网站资源会更有效？"><a href="#7、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="7、为什么利用多个域名来存储网站资源会更有效？"></a>7、为什么利用多个域名来存储网站资源会更有效？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CDN 缓存更方便</span><br><span class="line">突破浏览器并发限制</span><br><span class="line">节约 cookie 带宽</span><br><span class="line">节约主域名的连接数，优化页面响应速度</span><br><span class="line">防止不必要的安全问题</span><br></pre></td></tr></table></figure><h3 id="8、网页标准和标准制定机构重要性的理解。"><a href="#8、网页标准和标准制定机构重要性的理解。" class="headerlink" title="8、网页标准和标准制定机构重要性的理解。"></a>8、网页标准和标准制定机构重要性的理解。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网页标准和标准制定机构都是为了能让 web 发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO 也会更好做，也不会因为滥用代码导致各种 BUG、安全问题，最终提高网站易用性。</span><br></pre></td></tr></table></figure><h3 id="9、cookies，sessionStorage-和-localStorage-的区别"><a href="#9、cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="9、cookies，sessionStorage 和 localStorage 的区别"></a>9、cookies，sessionStorage 和 localStorage 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage （session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</span><br><span class="line">而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</span><br><span class="line">Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。</span><br><span class="line">Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。</span><br><span class="line">除此之外，Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie需要前端开发者自己封装 setCookie，getCookie。但是 Cookie 也是不可以或缺的：Cookie的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。</span><br></pre></td></tr></table></figure><h3 id="10、src-与-href-的区别"><a href="#10、src-与-href-的区别" class="headerlink" title="10、src 与 href 的区别"></a>10、src 与 href 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</span><br><span class="line">src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。</span><br><span class="line">当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。</span><br><span class="line">href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</span><br></pre></td></tr></table></figure><h3 id="11、网页制作会用到的图片格式有哪些？"><a href="#11、网页制作会用到的图片格式有哪些？" class="headerlink" title="11、网页制作会用到的图片格式有哪些？"></a>11、网页制作会用到的图片格式有哪些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">png-8，png-24，jpeg，gif，svg。</span><br><span class="line">但是上面的那些都不是面试官想要的最后答案。面试官希望听到是 Webp。（是否有关注新技术，新鲜事物）</span><br><span class="line">科普一下 Webp：WebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay 等知名网站已经开始测试并使用 WebP 格式。在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小 40%</span><br></pre></td></tr></table></figure><h3 id="12、什么是微格式吗？在前端构建中应该考虑微格式吗？"><a href="#12、什么是微格式吗？在前端构建中应该考虑微格式吗？" class="headerlink" title="12、什么是微格式吗？在前端构建中应该考虑微格式吗？"></a>12、什么是微格式吗？在前端构建中应该考虑微格式吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微格式（Microformats）是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。</span><br><span class="line">优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣，有兴趣自行 google）</span><br></pre></td></tr></table></figure><h3 id="13、一次js请求一般情况下有哪些地方会有缓存处理？"><a href="#13、一次js请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="13、一次js请求一般情况下有哪些地方会有缓存处理？"></a>13、一次js请求一般情况下有哪些地方会有缓存处理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案：dns 缓存，cdn 缓存，浏览器缓存，服务器缓存。</span><br></pre></td></tr></table></figure><h3 id="14、一个页面上有大量的图片，加载很慢，怎么优化这些图片的加载给用户更好的体验。"><a href="#14、一个页面上有大量的图片，加载很慢，怎么优化这些图片的加载给用户更好的体验。" class="headerlink" title="14、一个页面上有大量的图片，加载很慢，怎么优化这些图片的加载给用户更好的体验。"></a>14、一个页面上有大量的图片，加载很慢，怎么优化这些图片的加载给用户更好的体验。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</span><br><span class="line">如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</span><br><span class="line">如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。</span><br><span class="line">如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</span><br><span class="line">如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</span><br></pre></td></tr></table></figure><h3 id="15、你如何理解-HTML-结构的语义化？"><a href="#15、你如何理解-HTML-结构的语义化？" class="headerlink" title="15、你如何理解 HTML 结构的语义化？"></a>15、你如何理解 HTML 结构的语义化？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当页面样式加载失败的时候能够让页面呈现出清晰的结构</span><br><span class="line">有利于 seo 优化，利于被搜索引擎收录（更便于搜索引擎的爬虫程序来识别）</span><br><span class="line">便于项目的开发及维护，使 html 代码更具有可读性，便于其他设备解析。</span><br></pre></td></tr></table></figure><h3 id="16、做好-SEO-需要考虑什么？"><a href="#16、做好-SEO-需要考虑什么？" class="headerlink" title="16、做好 SEO 需要考虑什么？"></a>16、做好 SEO 需要考虑什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Meta 标签优化:主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如 Author（作者），Category（目录），Language（编码语种）等。</span><br><span class="line">放置关键词:关键词分析和选择是 SEO 最重要的工作之一。首先要给网站确定主关键词（一般在 5 个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。</span><br><span class="line">虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing 等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如 AOL 网页搜</span><br><span class="line">索用的是 Google 的搜索技术，MSN 用的是 Bing 的技术。</span><br><span class="line">Open Directory 自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。</span><br><span class="line">搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有 Overture 和百度，当然也包括 Google 的广告项目 Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。</span><br><span class="line">网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如 Yahoo 要 299 美元），但是好消息是（至少到目前为止）最大的搜索引</span><br><span class="line">擎 Google 目前还是免费，而且它主宰着 60％以上的搜索市场。链接交换和链接广泛度（Link Popularity）</span><br><span class="line">网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来 Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。</span><br><span class="line">合理的标签使用</span><br></pre></td></tr></table></figure><h3 id="17、怎么对一个-DOM-设置它的-CSS-样式？"><a href="#17、怎么对一个-DOM-设置它的-CSS-样式？" class="headerlink" title="17、怎么对一个 DOM 设置它的 CSS 样式？"></a>17、怎么对一个 DOM 设置它的 CSS 样式？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外部样式表，引入一个外部 css 文件</span><br><span class="line">内部样式表，将 css 代码放在 &lt;head&gt; 标签内部</span><br><span class="line">内联样式，将 css 样式直接定义在 HTML 元素内部</span><br></pre></td></tr></table></figure><h3 id="18、CSS-都有哪些选择器？"><a href="#18、CSS-都有哪些选择器？" class="headerlink" title="18、CSS 都有哪些选择器？"></a>18、CSS 都有哪些选择器？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">派生选择器（用 HTML 标签申明）</span><br><span class="line">id 选择器（用 DOM 的 ID 申明）</span><br><span class="line">类选择器（用一个样式类名申明）</span><br><span class="line">属性选择器（用 DOM 的属性申明，属于 CSS2，IE6 不支持，不常用，不知道就算了）</span><br><span class="line">除了前 3 种基本选择器，还有一些扩展选择器，包括</span><br><span class="line">后代选择器（利用空格间隔，比如 div .a&#123; &#125;）</span><br><span class="line">群组选择器（利用逗号间隔，比如 p,div,#a&#123; &#125;）</span><br><span class="line">那么问题来了，CSS 选择器的优先级是怎么样定义的？</span><br><span class="line">基本原则：一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。</span><br></pre></td></tr></table></figure><h3 id="19、定义一个-DOM-元素不显示在浏览器可视范围内？"><a href="#19、定义一个-DOM-元素不显示在浏览器可视范围内？" class="headerlink" title="19、定义一个 DOM 元素不显示在浏览器可视范围内？"></a>19、定义一个 DOM 元素不显示在浏览器可视范围内？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本的：设置 display 属性为 none，或者设置 visibility 属性为 hidden</span><br><span class="line">技巧性：设置宽高为 0，设置透明度为 0，设置 z-index 位置在-1000</span><br></pre></td></tr></table></figure><h3 id="20、超链接访问过后-hover-样式就不出现的问题是什么？"><a href="#20、超链接访问过后-hover-样式就不出现的问题是什么？" class="headerlink" title="20、超链接访问过后 hover 样式就不出现的问题是什么？"></a>20、超链接访问过后 hover 样式就不出现的问题是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被点击访问过的超链接样式不在具有 hover 和 active 了,解决方法是改变 CSS 属性的</span><br><span class="line">排列顺序: L-V-H-A（link,visited,hover,active）</span><br></pre></td></tr></table></figure><h3 id="21、什么是-Css-Hack？ie6-7-8-的-hack-分别是什么？"><a href="#21、什么是-Css-Hack？ie6-7-8-的-hack-分别是什么？" class="headerlink" title="21、什么是 Css Hack？ie6,7,8 的 hack 分别是什么？"></a>21、什么是 Css Hack？ie6,7,8 的 hack 分别是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">针对不同的浏览器写不同的 CSS code 的过程，就是 CSS hack。示例如下：</span><br><span class="line">#test &#123;</span><br><span class="line">width:300px;</span><br><span class="line">height:300px;</span><br><span class="line">background-color:blue; /*firefox*/</span><br><span class="line">background-color:red\9; /*all ie*/</span><br><span class="line">background-color:yellow; /*ie8*/</span><br><span class="line">+background-color:pink; /*ie7*/</span><br><span class="line">_background-color:orange; /*ie6*/ &#125;</span><br><span class="line">:root #test &#123; background-color:purple\9; &#125; /*ie9*/</span><br><span class="line">@media all and (min-width:0px)&#123; #test &#123;background-color:black;&#125; &#125; /*opera*/</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio:0)&#123; #test &#123;background-color:gray;&#125; &#125; /*chrome</span><br><span class="line">and safari*/</span><br></pre></td></tr></table></figure><h3 id="23、行内元素和块级元素的区别是什么？行内元素的-padding-和-margin-可设置吗？"><a href="#23、行内元素和块级元素的区别是什么？行内元素的-padding-和-margin-可设置吗？" class="headerlink" title="23、行内元素和块级元素的区别是什么？行内元素的 padding 和 margin 可设置吗？"></a>23、行内元素和块级元素的区别是什么？行内元素的 padding 和 margin 可设置吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">块级元素(block)特性：总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</span><br><span class="line">内联元素(inline)特性：和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的 top/bottom(padding-top/padding-bottom)和外边</span><br><span class="line">距的 top/bottom(margin-top/margin-bottom)都不可改变（也就是 padding 和 margin 的left 和 right 是可以设置的），就是里面文字或图片的大小。</span><br><span class="line">那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行）：&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。</span><br></pre></td></tr></table></figure><h3 id="24、什么是外边距重叠？重叠的结果是什么？"><a href="#24、什么是外边距重叠？重叠的结果是什么？" class="headerlink" title="24、什么是外边距重叠？重叠的结果是什么？"></a>24、什么是外边距重叠？重叠的结果是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">外边距重叠就是 margin-collapse。</span><br><span class="line">在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</span><br><span class="line">折叠结果遵循下列计算规则：</span><br><span class="line">两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</span><br><span class="line">两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</span><br><span class="line">两个外边距一正一负时，折叠结果是两者的相加的和。</span><br></pre></td></tr></table></figure><h3 id="26、rgba-和-opacity-的透明效果有什么不同？"><a href="#26、rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="26、rgba()和 opacity 的透明效果有什么不同？"></a>26、rgba()和 opacity 的透明效果有什么不同？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度，</span><br><span class="line">而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）</span><br></pre></td></tr></table></figure><h3 id="27、让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#27、让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="27、让文字在垂直和水平方向上重叠的两个属性是什么？"></a>27、让文字在垂直和水平方向上重叠的两个属性是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">垂直方向：line-height</span><br><span class="line">水平方向：letter-spacing</span><br><span class="line">关于 letter-spacing 的妙用可以用于消除 inline-block 元素间的换行符空格间隙问题。</span><br></pre></td></tr></table></figure><h3 id="28、如何垂直居中一个浮动元素？"><a href="#28、如何垂直居中一个浮动元素？" class="headerlink" title="28、如何垂直居中一个浮动元素？"></a>28、如何垂直居中一个浮动元素？</h3><p>方法一：已知元素的高宽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.div1&#123;</span><br><span class="line">background-color:#6699FF;</span><br><span class="line">width:200px;</span><br><span class="line">height:200px;</span><br><span class="line">position: absolute; //父元素需要相对定位</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-top:-100px ; //二分之一的 height，width</span><br><span class="line">margin-left: -100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二:未知元素的高宽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.div1&#123;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">background-color: #6699FF;</span><br><span class="line">margin:auto;</span><br><span class="line">position: absolute; //父元素需要相对定位</span><br><span class="line">left: 0;</span><br><span class="line">top: 0;</span><br><span class="line">right: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何垂直居中一个img?（用更简便的方法。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.container //img的容器设置如下</span><br><span class="line">&#123;</span><br><span class="line">display:table-cell;</span><br><span class="line">text-align:center;</span><br><span class="line">vertical-align:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="29、px-和-em-的区别"><a href="#29、px-和-em-的区别" class="headerlink" title="29、px 和 em 的区别"></a>29、px 和 em 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">px 和 em 都是长度单位，区别是，px 的值是固定的，指定是多少就是多少，计算比较容易。</span><br><span class="line">em 得值不是固定的，并且 em 会继承父级元素的字体大小。</span><br><span class="line">浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。</span><br></pre></td></tr></table></figure><h3 id="30、”reset”的-CSS-文件如何使用？和-normalize-css-的不同之处？"><a href="#30、”reset”的-CSS-文件如何使用？和-normalize-css-的不同之处？" class="headerlink" title="30、”reset”的 CSS 文件如何使用？和 normalize.css 的不同之处？"></a>30、”reset”的 CSS 文件如何使用？和 normalize.css 的不同之处？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置 CSS 文件并知道如何使用它们。原因是不同的浏览器对一些元素有不同的</span><br><span class="line">默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。</span><br><span class="line">你可能会用 Normalize 来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗</span><br><span class="line">体的标题）。</span><br><span class="line">在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像 HTML 的 audio 元素不一致或 line-height 不一致。</span><br></pre></td></tr></table></figure><h3 id="31、Sass、LESS-是什么？为什么要使用他们？"><a href="#31、Sass、LESS-是什么？为什么要使用他们？" class="headerlink" title="31、Sass、LESS 是什么？为什么要使用他们？"></a>31、Sass、LESS 是什么？为什么要使用他们？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">他们是 CSS 预处理器。他是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。</span><br><span class="line">例如 Less 是一种动态样式语言. 将 CSS 结构清晰，便于扩展。</span><br><span class="line">可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。</span><br><span class="line">可以轻松实现多重继承。</span><br><span class="line">完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</span><br></pre></td></tr></table></figure><h3 id="32、display-none-与-visibility-hidden-的区别是什么？"><a href="#32、display-none-与-visibility-hidden-的区别是什么？" class="headerlink" title="32、display:none 与 visibility:hidden 的区别是什么？"></a>32、display:none 与 visibility:hidden 的区别是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display : 隐藏对应的元素但不挤占该元素原来的空间。</span><br><span class="line">visibility: 隐藏对应的元素并且挤占该元素原来的空间。</span><br></pre></td></tr></table></figure><h3 id="33、CSS-中-link-和-import-的区别是："><a href="#33、CSS-中-link-和-import-的区别是：" class="headerlink" title="33、CSS 中 link 和@import 的区别是："></a>33、CSS 中 link 和@import 的区别是：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Link 属于 html 标签，而@import 是 CSS 中提供的在页面加载的时候，link 会同时被加载，而@import 引用的 CSS 会在页面加载完成后才会加</span><br><span class="line">载引用的 CSS</span><br><span class="line">@import 只有在 ie5 以上才可以被识别，而 link 是 html 标签，不存在浏览器兼容性问题</span><br><span class="line">Link 引入样式的权重大于@import 的引用（@import 是将引用的样式导入到当前的页面中）</span><br></pre></td></tr></table></figure><h3 id="34、BFC-是什么"><a href="#34、BFC-是什么" class="headerlink" title="34、BFC 是什么?"></a>34、BFC 是什么?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BFC（块级格式化上下文），一个创建了新的 BFC 的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个 BFC 中的两个相邻的盒子在垂直方向发生 margin 重叠的问题</span><br><span class="line">BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用</span><br></pre></td></tr></table></figure><h3 id="35、HTML-与-XHTML——二者有什么区别？"><a href="#35、HTML-与-XHTML——二者有什么区别？" class="headerlink" title="35、HTML 与 XHTML——二者有什么区别？"></a>35、HTML 与 XHTML——二者有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 所有的标记都必须要有一个相应的结束标记</span><br><span class="line">2. 所有标签的元素和属性的名字都必须使用小写</span><br><span class="line">3. 所有的 XML 标记都必须合理嵌套</span><br><span class="line">4. 所有的属性必须用引号 &quot;&quot; 括起来</span><br><span class="line">5. 把所有 &lt; 和 &amp; 特殊符号用编码表示</span><br><span class="line">6. 给所有属性赋一个值</span><br><span class="line">7. 不要在注释内容中使用 &quot;--&quot;</span><br><span class="line">8. 图片必须有说明文字</span><br></pre></td></tr></table></figure><h3 id="36、html-常见兼容性问题？"><a href="#36、html-常见兼容性问题？" class="headerlink" title="36、html 常见兼容性问题？"></a>36、html 常见兼容性问题？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">双边距 BUG float 引起的 加入_display：inline</span><br><span class="line">3像素问题 使用 float 引起的 使用 dislpay:inline -3px</span><br><span class="line">超链接 hover 点击后失效 使用正确的书写顺序 link visited hover active</span><br><span class="line">Ie z-index 问题 给父级添加 position:relative</span><br><span class="line">Png 透明 使用 js 代码 改</span><br><span class="line">Min-height 最小高度 ！Important 解决’</span><br><span class="line">select 在 ie6 下遮盖 使用 iframe 嵌套</span><br><span class="line">没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）</span><br><span class="line">IE5-8 不支持 opacity，解决办法：</span><br><span class="line">.opacity &#123;</span><br><span class="line">opacity: 0.4</span><br><span class="line">filter: alpha(opacity=60); /* for IE5-7 */</span><br><span class="line">-ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;; /* for IE8*/</span><br><span class="line">&#125;</span><br><span class="line">IE6 不支持 PNG 透明背景，解决办法: IE6 下使用 gif 图片,或是做成 PNG8.</span><br></pre></td></tr></table></figure><h3 id="37、对-WEB-标准以及-W3C-的理解与认识"><a href="#37、对-WEB-标准以及-W3C-的理解与认识" class="headerlink" title="37、对 WEB 标准以及 W3C 的理解与认识"></a>37、对 WEB 标准以及 W3C 的理解与认识</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链 css 和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。</span><br></pre></td></tr></table></figure><h3 id="38、行内元素、块级元素、空-void-元素有哪些-CSS-的盒模型"><a href="#38、行内元素、块级元素、空-void-元素有哪些-CSS-的盒模型" class="headerlink" title="38、行内元素、块级元素、空(void)元素有哪些?CSS 的盒模型?"></a>38、行内元素、块级元素、空(void)元素有哪些?CSS 的盒模型?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">块级元素：div p h1 h2 h3 h4 form ul</span><br><span class="line">行内元素: a b br i span input select</span><br><span class="line">Css盒模型:内容，border ,margin，padding</span><br><span class="line">知名的空元素：&lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt;</span><br><span class="line">鲜为人知的是： &lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;command&gt;&lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt;</span><br></pre></td></tr></table></figure><h3 id="39、前端页面有哪三层构成，分别是什么-作用是什么"><a href="#39、前端页面有哪三层构成，分别是什么-作用是什么" class="headerlink" title="39、前端页面有哪三层构成，分别是什么?作用是什么?"></a>39、前端页面有哪三层构成，分别是什么?作用是什么?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构层 Html 表示层 CSS 行为层 js。</span><br></pre></td></tr></table></figure><h3 id="40、Doctype-作用-严格模式与混杂模式区分它们有何意义"><a href="#40、Doctype-作用-严格模式与混杂模式区分它们有何意义" class="headerlink" title="40、Doctype 作用? 严格模式与混杂模式区分它们有何意义?"></a>40、Doctype 作用? 严格模式与混杂模式区分它们有何意义?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。</span><br><span class="line">严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</span><br><span class="line">在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</span><br><span class="line">DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。</span><br></pre></td></tr></table></figure><h3 id="41、b-标签和-strong-标签-i-标签和-em-标签的区别？"><a href="#41、b-标签和-strong-标签-i-标签和-em-标签的区别？" class="headerlink" title="41、b 标签和 strong 标签,i 标签和 em 标签的区别？"></a>41、b 标签和 strong 标签,i 标签和 em 标签的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后者有语义，前者则无。</span><br></pre></td></tr></table></figure><h3 id="42、CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？"><a href="#42、CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？" class="headerlink" title="42、CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？"></a>42、CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 1.id 选择器（ # myid）</span><br><span class="line">2.类选择器（.myclassname）</span><br><span class="line">3.标签选择器（div, h1, p）</span><br><span class="line">4.相邻选择器（h1 + p）</span><br><span class="line">5.子选择器（ul &lt; li）</span><br><span class="line">6.后代选择器（li a）</span><br><span class="line">7.通配符选择器（ * ）</span><br><span class="line">8.属性选择器（a[rel = &quot;external&quot;]）</span><br><span class="line">9.伪类选择器（a: hover, li: nth - child）</span><br><span class="line">* 可继承： font-size font-family color, UL LI DL DD DT;</span><br><span class="line">* 不可继承 ：border padding margin width height ;</span><br><span class="line">* 优先级就近原则，样式定义最近者为准;</span><br><span class="line">* 载入样式以最后载入的定位为准;</span><br><span class="line">优先级为:!important &gt; id &gt; class &gt; tag</span><br><span class="line">important 比 内联优先级高</span><br></pre></td></tr></table></figure><h2 id="HTML5和CSS3"><a href="#HTML5和CSS3" class="headerlink" title="HTML5和CSS3"></a>HTML5和CSS3</h2><h3 id="1、CSS3-有哪些新特性？"><a href="#1、CSS3-有哪些新特性？" class="headerlink" title="1、CSS3 有哪些新特性？"></a>1、CSS3 有哪些新特性？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSS3 实现圆角（border-radius），阴影（box-shadow），</span><br><span class="line">对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</span><br><span class="line">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px)skew(-9deg,0deg);// 旋转,缩放,定位,倾斜</span><br><span class="line">增加了更多的 CSS 选择器 多背景 rgba</span><br><span class="line">在 CSS3 中唯一引入的伪元素是 ::selection.</span><br><span class="line">媒体查询, 多栏布局, border-image</span><br></pre></td></tr></table></figure><h3 id="2、html5-有哪些新特性、移除了那些元素？如何区分-HTML-和-HTML5？"><a href="#2、html5-有哪些新特性、移除了那些元素？如何区分-HTML-和-HTML5？" class="headerlink" title="2、html5 有哪些新特性、移除了那些元素？如何区分 HTML 和 HTML5？"></a>2、html5 有哪些新特性、移除了那些元素？如何区分 HTML 和 HTML5？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">新特性：HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，地理定位等功能的增加</span><br><span class="line">拖拽释放(Drag and drop) API</span><br><span class="line">语义化更好的内容标签（header,nav,footer,aside,article,section）</span><br><span class="line">音频、视频 API(audio,video)</span><br><span class="line">画布(Canvas) API</span><br><span class="line">地理(Geolocation) API</span><br><span class="line">本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</span><br><span class="line">sessionStorage 的数据在浏览器关闭后自动删除</span><br><span class="line">表单控件，calendar、date、time、email、url、search</span><br><span class="line">新的技术 webworker, websocket, Geolocation</span><br><span class="line">移除的元素：</span><br><span class="line">纯表现的元素：basefont，big，center，font, s，strike，tt，u；</span><br><span class="line">对可用性产生负面影响的元素：frame，frameset，noframes；</span><br><span class="line">支持 HTML5 新标签：</span><br><span class="line">1. IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架）：</span><br><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOCTYPE 声明新增的结构元素、功能元素本地存储（Local Storage ）和 cookies（储存在用户本地终端上的数据）</span><br><span class="line">Cookies:服务器和客户端都可以访问；大小只有 4KB 左右；有有效期，过期后将会删除；</span><br><span class="line">本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过 POST 或者 GET 的通道发送到服务器；每个域 5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用 Javascript 代码移除</span><br></pre></td></tr></table></figure><h3 id="4、如何实现浏览器内多个标签页之间的通信"><a href="#4、如何实现浏览器内多个标签页之间的通信" class="headerlink" title="4、如何实现浏览器内多个标签页之间的通信?"></a>4、如何实现浏览器内多个标签页之间的通信?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用 localstorge、cookies 等本地存储方式</span><br></pre></td></tr></table></figure><h3 id="5、你如何对网站的文件和资源进行优化？"><a href="#5、你如何对网站的文件和资源进行优化？" class="headerlink" title="5、你如何对网站的文件和资源进行优化？"></a>5、你如何对网站的文件和资源进行优化？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件合并</span><br><span class="line">文件最小化/文件压缩</span><br><span class="line">使用 CDN 托管</span><br><span class="line">缓存的使用</span><br></pre></td></tr></table></figure><h3 id="6、什么是响应式设计？"><a href="#6、什么是响应式设计？" class="headerlink" title="6、什么是响应式设计？"></a>6、什么是响应式设计？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常</span><br></pre></td></tr></table></figure><h3 id="7、新的-HTML5-文档类型和字符集是？"><a href="#7、新的-HTML5-文档类型和字符集是？" class="headerlink" title="7、新的 HTML5 文档类型和字符集是？"></a>7、新的 HTML5 文档类型和字符集是？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML5 文档类型：&lt;!doctype html&gt;</span><br><span class="line">HTML5 使用的编码&lt;meta charset=”UTF-8”&gt;</span><br></pre></td></tr></table></figure><h3 id="8、HTML5-Canvas-元素有什么用？"><a href="#8、HTML5-Canvas-元素有什么用？" class="headerlink" title="8、HTML5 Canvas 元素有什么用？"></a>8、HTML5 Canvas 元素有什么用？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。</span><br></pre></td></tr></table></figure><h3 id="9、HTML5-存储类型有什么区别？"><a href="#9、HTML5-存储类型有什么区别？" class="headerlink" title="9、HTML5 存储类型有什么区别？"></a>9、HTML5 存储类型有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Media API、Text Track API、Application Cache API、User Interaction、Data TransferAPI、Command API、Constraint Validation API、History API</span><br></pre></td></tr></table></figure><h3 id="10、CSS3-新增伪类有那些？"><a href="#10、CSS3-新增伪类有那些？" class="headerlink" title="10、CSS3 新增伪类有那些？"></a>10、CSS3 新增伪类有那些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">:enabled、:disabled 控制表单控件的禁用状态。</span><br><span class="line">:checked，单选框或复选框被选中。</span><br></pre></td></tr></table></figure><h3 id="11、前端应该如何高质量完成工作"><a href="#11、前端应该如何高质量完成工作" class="headerlink" title="11、前端应该如何高质量完成工作?"></a>11、前端应该如何高质量完成工作?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先划分成头部、body、脚部；</span><br><span class="line">实现效果图是最基本的工作，精确到 2px；</span><br><span class="line">与设计师，产品经理的沟通和项目的参与</span><br><span class="line">做好的页面结构，页面重构和用户体验</span><br><span class="line">处理 hack，兼容、写出优美的代码格式</span><br><span class="line">针对服务器的优化、拥抱 HTML5。</span><br></pre></td></tr></table></figure><h3 id="12、css中content属性的作用"><a href="#12、css中content属性的作用" class="headerlink" title="12、css中content属性的作用"></a>12、css中content属性的作用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">css 的 content 属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。</span><br><span class="line">//一种常见利用伪类清除浮动的代码</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">content:&quot;.&quot;; //这里利用到了 content 属性</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">clear:both; &#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">*zoom:1;</span><br><span class="line">&#125;</span><br><span class="line">after 伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用clear:both 清除浮动。</span><br><span class="line">那么问题继续还有，知道 css 计数器（序列数字字符自动递增）吗？如何通过css content 属性实现 css 计数器？</span><br><span class="line">css 计数器是通过设置 counter-reset 、counter-increment 两个属性 、及counter()/counters()一个方法配合 after / before 伪类实现。</span><br></pre></td></tr></table></figure><h3 id="13、在HTML5页面中嵌入音频"><a href="#13、在HTML5页面中嵌入音频" class="headerlink" title="13、在HTML5页面中嵌入音频"></a>13、在HTML5页面中嵌入音频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：</span><br><span class="line">&lt;audio controls&gt;</span><br><span class="line">&lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&gt;</span><br><span class="line">Your browser does&apos;nt support audio embedding feature.</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure><h3 id="14、在HTML5页面中嵌入视频"><a href="#14、在HTML5页面中嵌入视频" class="headerlink" title="14、在HTML5页面中嵌入视频"></a>14、在HTML5页面中嵌入视频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：</span><br><span class="line">&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt;</span><br><span class="line">&lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">Your browser does&apos;nt support video embedding feature.</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h3 id="15、写一个css3幻灯片效果页面"><a href="#15、写一个css3幻灯片效果页面" class="headerlink" title="15、写一个css3幻灯片效果页面"></a>15、写一个css3幻灯片效果页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.ani&#123;</span><br><span class="line">width:480px;</span><br><span class="line">height:320px;</span><br><span class="line">margin:50px auto;</span><br><span class="line">overflow: hidden;</span><br><span class="line">box-shadow:0 0 5px rgba(0,0,0,1);</span><br><span class="line">background-size: cover;</span><br><span class="line">background-position: center;</span><br><span class="line">-webkit-animation-name: &quot;loops&quot;;</span><br><span class="line">-webkit-animation-duration: 20s;</span><br><span class="line">-webkit-animation-iteration-count: infinite;</span><br><span class="line">&#125;</span><br><span class="line">@-webkit-keyframes &quot;loops&quot; &#123;</span><br><span class="line">0%</span><br><span class="line">&#123; background:url(&apos;&apos;) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">background:url(&apos;&apos;) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">background:url(&apos;&apos;) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> Div+css </tag>
            
            <tag> Html5+css3 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
